# Лабораторна робота 6. Робота з СУБД MongoDB та реалізація операцій

## Тема

Документо-орієнтовані бази даних. Основи роботи з MongoDB

## Мета

Освоїти принципи роботи з NoSQL документо-орієнтованою базою даних MongoDB, навчитися виконувати базові операції створення, читання, оновлення та видалення документів, опанувати механізми запитів та індексування, розвинути розуміння відмінностей між реляційним та документним підходами до зберігання даних.

## Завдання

### Рівень 1 (обов'язковий мінімум)

1. Встановити MongoDB Community Edition та MongoDB Compass.
2. Створити базу даних `library` з колекціями `books`, `authors`, `users`.
3. Додати по 10 документів в кожну колекцію з використанням різних структур (вкладені документи, масиви).
4. Виконати базові CRUD операції:
    - Вставка одного та багатьох документів.
    - Пошук документів з різними умовами (рівність, порівняння, логічні оператори).
    - Оновлення полів документів.
    - Видалення документів за умовами.
5. Створити три різних індекси для оптимізації пошуку.
6. Порівняти швидкість виконання запитів з індексами та без них.

### Рівень 2 (додаткова функціональність)

Додатково до рівня 1:

1. Реалізувати складні запити з використанням операторів `$and`, `$or`, `$in`, `$regex`.
2. Виконати агрегаційні запити з використанням pipeline:
    - Підрахунок кількості документів за категоріями.
    - Обчислення середніх значень.
    - Групування та сортування результатів.
3. Створити складені (compound) індекси для оптимізації складних запитів.
4. Реалізувати текстовий пошук з індексом типу `text`.
5. Використати оператор `$lookup` для об'єднання даних з різних колекцій (аналог JOIN).
6. Створити представлення (view) для часто використовуваних запитів.

### Рівень 3 (творче розширення)

Додатково до рівня 2:

1. Реалізувати валідацію схеми документів з використанням JSON Schema.
2. Створити геопросторові індекси та виконати запити на основі координат.
3. Розробити систему версіонування документів з збереженням історії змін.
4. Реалізувати повнотекстовий пошук з підтримкою української мови.
5. Налаштувати реплікацію даних між кількома інстансами MongoDB (якщо можливо).
6. Створити скрипт для автоматизованого резервного копіювання з використанням `mongodump`.
7. Розробити порівняльний аналіз між реляційним та документним підходом для конкретної предметної області.

## Теоретичні відомості

### Основи NoSQL та документо-орієнтованих баз даних

NoSQL (Not Only SQL) це клас систем управління базами даних, які відрізняються від традиційних реляційних СУБД відсутністю жорсткої табличної схеми, горизонтальною масштабованістю та підтримкою розподілених архітектур. Документо-орієнтовані бази даних, такі як MongoDB, зберігають дані у форматі, схожому на JSON (у MongoDB це BSON — Binary JSON), що дозволяє гнучко моделювати складні структури даних без необхідності нормалізації.

**Переваги документного підходу:**

- **Гнучкість схеми** — можливість змінювати структуру документів без міграцій бази даних.
- **Природність моделювання** — структура документів відповідає об'єктам у коді програми.
- **Ефективність** — можливість отримати всі пов'язані дані одним запитом без JOIN операцій.
- **Горизонтальна масштабованість** — легке розподілення даних між серверами (sharding).

**Недоліки порівняно з реляційними СУБД:**

- **Обмежені можливості транзакцій** — хоча MongoDB підтримує ACID транзакції, вони складніші в реалізації.
- **Дублювання даних** — денормалізована природа може призводити до надмірності.
- **Складність складних запитів** — відсутність декларативного SQL може ускладнити деякі операції.

### Структура даних в MongoDB

MongoDB зберігає дані у вигляді документів BSON (Binary JSON), які об'єднуються в колекції. Кожен документ має унікальний ідентифікатор `_id`, який автоматично генерується якщо не вказаний явно.

**Приклад структури документа:**

```json
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "title": "Майстер і Маргарита",
  "author": {
    "name": "Михайло Булгаков",
    "birth_year": 1891,
    "nationality": "російський"
  },
  "genres": ["роман", "містика", "філософія"],
  "publication_year": 1967,
  "pages": 480,
  "isbn": "978-966-03-3527-6",
  "available": true,
  "ratings": [
    { "user": "user123", "score": 5, "date": ISODate("2024-03-15") },
    { "user": "user456", "score": 4, "date": ISODate("2024-03-20") }
  ]
}
```

Документи можуть містити:

- **Прості типи даних:** string, number, boolean, date, null.
- **Вкладені документи:** об'єкти всередині об'єктів.
- **Масиви:** списки значень або документів.
- **Спеціальні типи:** ObjectId, Binary Data, Regular Expression.

### CRUD операції в MongoDB

**Create (Створення):**

```javascript
// Вставка одного документа
db.books.insertOne({
  title: "Тіні забутих предків",
  author: "Михайло Коцюбинський",
  publication_year: 1911,
  genres: ["повість", "романтизм"],
  available: true
});

// Вставка багатьох документів
db.books.insertMany([
  {
    title: "Кобзар",
    author: "Тарас Шевченко",
    publication_year: 1840,
    genres: ["поезія"]
  },
  {
    title: "Лісова пісня",
    author: "Леся Українка",
    publication_year: 1911,
    genres: ["драма", "феєрія"]
  }
]);
```

**Read (Читання):**

```javascript
// Пошук всіх документів
db.books.find();

// Пошук з умовою
db.books.find({ author: "Тарас Шевченко" });

// Пошук з множинними умовами
db.books.find({
  publication_year: { $gte: 1900 },
  available: true
});

// Пошук одного документа
db.books.findOne({ title: "Кобзар" });

// Проєкція полів (вибір конкретних полів)
db.books.find(
  { genres: "поезія" },
  { title: 1, author: 1, _id: 0 }
);

// Сортування та обмеження
db.books.find().sort({ publication_year: -1 }).limit(5);
```

**Update (Оновлення):**

```javascript
// Оновлення одного документа
db.books.updateOne(
  { title: "Кобзар" },
  { $set: { available: false } }
);

// Оновлення багатьох документів
db.books.updateMany(
  { publication_year: { $lt: 1900 } },
  { $set: { category: "класика" } }
);

// Додавання елементу до масиву
db.books.updateOne(
  { title: "Майстер і Маргарита" },
  { $push: { genres: "сатира" } }
);

// Інкрементування числового значення
db.books.updateOne(
  { title: "Кобзар" },
  { $inc: { borrowed_count: 1 } }
);
```

**Delete (Видалення):**

```javascript
// Видалення одного документа
db.books.deleteOne({ title: "Застарілий довідник" });

// Видалення багатьох документів
db.books.deleteMany({ available: false });

// Видалення всіх документів з колекції
db.books.deleteMany({});
```

### Оператори запитів

MongoDB підтримує широкий набір операторів для побудови складних запитів:

**Оператори порівняння:**

```javascript
// $eq, $ne - рівність і нерівність
db.books.find({ publication_year: { $eq: 1911 } });
db.books.find({ available: { $ne: false } });

// $gt, $gte, $lt, $lte - більше, більше або дорівнює, менше, менше або дорівнює
db.books.find({ pages: { $gt: 300, $lte: 500 } });

// $in, $nin - входження в список
db.books.find({ genres: { $in: ["поезія", "драма"] } });
```

**Логічні оператори:**

```javascript
// $and - логічне І
db.books.find({
  $and: [
    { publication_year: { $gte: 1900 } },
    { available: true }
  ]
});

// $or - логічне АБО
db.books.find({
  $or: [
    { author: "Тарас Шевченко" },
    { genres: "поезія" }
  ]
});

// $not - логічне НІ
db.books.find({ pages: { $not: { $lt: 200 } } });
```

**Оператори для роботи з масивами:**

```javascript
// $all - всі елементи повинні бути присутні
db.books.find({ genres: { $all: ["роман", "містика"] } });

// $size - розмір масиву
db.books.find({ genres: { $size: 2 } });

// $elemMatch - співпадіння елементу масиву з умовою
db.books.find({
  ratings: {
    $elemMatch: { score: { $gte: 4 }, user: "user123" }
  }
});
```

**Оператор регулярних виразів:**

```javascript
// Пошук за шаблоном
db.books.find({ title: { $regex: /Майстер/i } });

// З урахуванням регістру
db.books.find({ author: { $regex: "^Михайло" } });
```

### Агрегаційний pipeline

Агрегаційний pipeline дозволяє виконувати складну обробку даних через послідовність етапів (stages).

**Основні етапи pipeline:**

```javascript
// $match - фільтрація документів
db.books.aggregate([
  { $match: { publication_year: { $gte: 1900 } } }
]);

// $group - групування та агрегація
db.books.aggregate([
  {
    $group: {
      _id: "$author",
      total_books: { $sum: 1 },
      avg_pages: { $avg: "$pages" }
    }
  }
]);

// $sort - сортування
db.books.aggregate([
  { $sort: { publication_year: -1 } }
]);

// $limit та $skip - обмеження та пропуск
db.books.aggregate([
  { $sort: { pages: -1 } },
  { $limit: 10 }
]);

// $project - проєкція полів
db.books.aggregate([
  {
    $project: {
      title: 1,
      author: 1,
      century: { $ceil: { $divide: ["$publication_year", 100] } }
    }
  }
]);

// $unwind - розгортання масивів
db.books.aggregate([
  { $unwind: "$genres" },
  { $group: { _id: "$genres", count: { $sum: 1 } } }
]);

// $lookup - об'єднання колекцій (JOIN)
db.books.aggregate([
  {
    $lookup: {
      from: "authors",
      localField: "author_id",
      foreignField: "_id",
      as: "author_details"
    }
  }
]);
```

**Приклад складного pipeline:**

```javascript
db.books.aggregate([
  // Етап 1: Фільтрація книг після 1900 року
  { $match: { publication_year: { $gte: 1900 } } },

  // Етап 2: Розгортання жанрів
  { $unwind: "$genres" },

  // Етап 3: Групування за жанрами
  {
    $group: {
      _id: "$genres",
      count: { $sum: 1 },
      avg_pages: { $avg: "$pages" },
      books: { $push: "$title" }
    }
  },

  // Етап 4: Сортування за кількістю
  { $sort: { count: -1 } },

  // Етап 5: Обмеження результатів
  { $limit: 5 }
]);
```

### Індексування в MongoDB

Індекси в MongoDB працюють аналогічно до реляційних баз даних, прискорюючи операції пошуку, сортування та об'єднання.

**Типи індексів:**

```javascript
// Простий індекс
db.books.createIndex({ title: 1 }); // 1 - зростання, -1 - спадання

// Складений індекс
db.books.createIndex({ author: 1, publication_year: -1 });

// Унікальний індекс
db.books.createIndex({ isbn: 1 }, { unique: true });

// Текстовий індекс для повнотекстового пошуку
db.books.createIndex({ title: "text", description: "text" });

// Геопросторовий індекс
db.locations.createIndex({ coordinates: "2dsphere" });

// TTL індекс для автоматичного видалення
db.sessions.createIndex(
  { created_at: 1 },
  { expireAfterSeconds: 3600 }
);
```

**Перевірка використання індексів:**

```javascript
// Аналіз плану виконання запиту
db.books.find({ author: "Тарас Шевченко" }).explain("executionStats");

// Список всіх індексів колекції
db.books.getIndexes();

// Видалення індексу
db.books.dropIndex("title_1");
```

### Валідація схеми

MongoDB дозволяє визначити правила валідації для документів в колекції з використанням JSON Schema.

```javascript
db.createCollection("books", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "publication_year"],
      properties: {
        title: {
          bsonType: "string",
          description: "Назва книги обов'язкова та має бути рядком"
        },
        author: {
          bsonType: "string",
          description: "Автор обов'язковий та має бути рядком"
        },
        publication_year: {
          bsonType: "int",
          minimum: 1000,
          maximum: 2100,
          description: "Рік видання має бути цілим числом між 1000 та 2100"
        },
        pages: {
          bsonType: "int",
          minimum: 1,
          description: "Кількість сторінок має бути додатнім цілим числом"
        },
        genres: {
          bsonType: "array",
          items: { bsonType: "string" },
          description: "Жанри мають бути масивом рядків"
        },
        available: {
          bsonType: "bool",
          description: "Доступність має бути булевим значенням"
        }
      }
    }
  }
});
```

## Хід роботи

### Крок 1. Встановлення MongoDB

**Для Windows:**

1. Завантажте MongoDB Community Edition з офіційного сайту: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)
2. Запустіть інсталятор та виберіть Complete installation.
3. Встановіть MongoDB Compass (графічний інтерфейс) під час інсталяції.
4. Після встановлення перевірте роботу MongoDB:

```bash
mongod --version
mongosh --version
```

**Для macOS:**

```bash
# Встановлення через Homebrew
brew tap mongodb/brew
brew install mongodb-community

# Запуск служби MongoDB
brew services start mongodb-community

# Встановлення MongoDB Compass
brew install --cask mongodb-compass
```

**Для Linux (Ubuntu/Debian):**

```bash
# Імпорт публічного ключа
wget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | sudo apt-key add -

# Додавання репозиторію
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list

# Оновлення та встановлення
sudo apt-get update
sudo apt-get install -y mongodb-org

# Запуск служби
sudo systemctl start mongod
sudo systemctl enable mongod
```

### Крок 2. Підключення до MongoDB

Запустіть MongoDB Shell (mongosh):

```bash
mongosh
```

Або використайте MongoDB Compass для графічного інтерфейсу, підключившись до `mongodb://localhost:27017`.

### Крок 3. Створення бази даних та колекцій

```javascript
// Перемикання на нову базу даних (створюється автоматично)
use library

// Створення колекцій з валідацією
db.createCollection("books", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "publication_year"],
      properties: {
        title: { bsonType: "string" },
        author: { bsonType: "string" },
        publication_year: { bsonType: "int", minimum: 1000 },
        pages: { bsonType: "int", minimum: 1 },
        genres: { bsonType: "array", items: { bsonType: "string" } },
        available: { bsonType: "bool" }
      }
    }
  }
});

db.createCollection("authors");
db.createCollection("users");
```

### Крок 4. Заповнення колекцій даними

```javascript
// Вставка авторів
db.authors.insertMany([
  {
    name: "Тарас Шевченко",
    birth_year: 1814,
    death_year: 1861,
    nationality: "український",
    biography: "Найвідоміший український поет, письменник, художник"
  },
  {
    name: "Леся Українка",
    birth_year: 1871,
    death_year: 1913,
    nationality: "український",
    biography: "Видатна українська письменниця, поетеса"
  },
  {
    name: "Іван Франко",
    birth_year: 1856,
    death_year: 1916,
    nationality: "український",
    biography: "Письменник, поет, публіцист, перекладач"
  },
  {
    name: "Михайло Коцюбинський",
    birth_year: 1864,
    death_year: 1913,
    nationality: "український",
    biography: "Український письменник-модерніст"
  },
  {
    name: "Панас Мирний",
    birth_year: 1849,
    death_year: 1920,
    nationality: "український",
    biography: "Український письменник-реаліст"
  }
]);

// Вставка книг
db.books.insertMany([
  {
    title: "Кобзар",
    author: "Тарас Шевченко",
    publication_year: 1840,
    pages: 238,
    isbn: "978-966-03-4421-6",
    genres: ["поезія", "романтизм"],
    available: true,
    description: "Збірка віршів Тараса Шевченка"
  },
  {
    title: "Лісова пісня",
    author: "Леся Українка",
    publication_year: 1911,
    pages: 128,
    isbn: "978-966-03-3918-2",
    genres: ["драма", "феєрія", "романтизм"],
    available: true,
    description: "Драма-феєрія за мотивами українського фольклору"
  },
  {
    title: "Захар Беркут",
    author: "Іван Франко",
    publication_year: 1883,
    pages: 256,
    isbn: "978-966-03-6127-5",
    genres: ["роман", "історична проза"],
    available: false,
    description: "Історичний роман про боротьбу карпатських горян"
  },
  {
    title: "Тіні забутих предків",
    author: "Михайло Коцюбинський",
    publication_year: 1911,
    pages: 96,
    isbn: "978-966-03-5214-3",
    genres: ["повість", "романтизм", "модернізм"],
    available: true,
    description: "Поетична повість про кохання в Карпатах"
  },
  {
    title: "Хіба ревуть воли, як ясла повні",
    author: "Панас Мирний",
    publication_year: 1880,
    pages: 384,
    isbn: "978-966-03-4856-6",
    genres: ["роман", "реалізм"],
    available: true,
    description: "Соціально-побутовий роман про життя селян"
  },
  {
    title: "Каменярі",
    author: "Іван Франко",
    publication_year: 1878,
    pages: 64,
    isbn: "978-966-03-7841-9",
    genres: ["поезія", "реалізм"],
    available: true,
    description: "Збірка соціальної поезії"
  },
  {
    title: "Конотопська відьма",
    author: "Григорій Квітка-Основ'яненко",
    publication_year: 1837,
    pages: 112,
    isbn: "978-966-03-3762-1",
    genres: ["повість", "містика"],
    available: true,
    description: "Перша українська романтична повість"
  },
  {
    title: "Маруся",
    author: "Григорій Квітка-Основ'яненко",
    publication_year: 1834,
    pages: 96,
    isbn: "978-966-03-4125-3",
    genres: ["повість", "сентименталізм"],
    available: false,
    description: "Сентиментальна повість про нещасливе кохання"
  },
  {
    title: "Камінний хрест",
    author: "Василь Стефаник",
    publication_year: 1900,
    pages: 48,
    isbn: "978-966-03-5427-7",
    genres: ["новела", "реалізм"],
    available: true,
    description: "Збірка новел про важке життя селян"
  },
  {
    title: "Intermezzo",
    author: "Михайло Коцюбинський",
    publication_year: 1909,
    pages: 72,
    isbn: "978-966-03-6843-4",
    genres: ["повість", "імпресіонізм"],
    available: true,
    description: "Імпресіоністична повість про кохання"
  }
]);

// Вставка користувачів
db.users.insertMany([
  {
    username: "ivan_petrov",
    email: "ivan.petrov@email.com",
    registration_date: new Date("2024-01-15"),
    borrowed_books: ["Кобзар", "Тіні забутих предків"],
    status: "active"
  },
  {
    username: "maria_kovalenko",
    email: "maria.kovalenko@email.com",
    registration_date: new Date("2024-02-20"),
    borrowed_books: ["Лісова пісня"],
    status: "active"
  },
  {
    username: "oleksandr_sydorov",
    email: "alex.sydorov@email.com",
    registration_date: new Date("2024-03-10"),
    borrowed_books: [],
    status: "active"
  },
  {
    username: "anna_melnyk",
    email: "anna.melnyk@email.com",
    registration_date: new Date("2023-11-05"),
    borrowed_books: ["Хіба ревуть воли, як ясла повні"],
    status: "active"
  },
  {
    username: "dmytro_bondar",
    email: "dmytro.bondar@email.com",
    registration_date: new Date("2024-01-28"),
    borrowed_books: ["Захар Беркут", "Каменярі"],
    status: "suspended"
  }
]);
```

### Крок 5. Виконання базових CRUD операцій

**Операції читання з різними умовами:**

```javascript
// Пошук всіх доступних книг
db.books.find({ available: true });

// Пошук книг конкретного автора
db.books.find({ author: "Іван Франко" });

// Пошук книг з кількістю сторінок більше 100
db.books.find({ pages: { $gt: 100 } });

// Пошук книг певного жанру
db.books.find({ genres: "поезія" });

// Пошук з логічними операторами
db.books.find({
  $or: [
    { author: "Тарас Шевченко" },
    { genres: "романтизм" }
  ]
});

// Пошук за шаблоном
db.books.find({ title: { $regex: /Лісова/i } });

// Пошук з проєкцією конкретних полів
db.books.find(
  { available: true },
  { title: 1, author: 1, pages: 1, _id: 0 }
);

// Пошук з сортуванням
db.books.find().sort({ publication_year: -1 });

// Пошук з обмеженням результатів
db.books.find({ genres: "роман" }).limit(3);
```

**Операції оновлення:**

```javascript
// Оновлення доступності книги
db.books.updateOne(
  { title: "Кобзар" },
  { $set: { available: false } }
);

// Додавання рейтингу до книги
db.books.updateOne(
  { title: "Лісова пісня" },
  {
    $push: {
      ratings: {
        user: "ivan_petrov",
        score: 5,
        date: new Date()
      }
    }
  }
);

// Оновлення багатьох документів
db.books.updateMany(
  { publication_year: { $lt: 1900 } },
  { $set: { category: "класика XIX століття" } }
);

// Інкрементування лічильника
db.books.updateOne(
  { title: "Тіні забутих предків" },
  { $inc: { borrowed_count: 1 } }
);

// Видалення поля з документа
db.books.updateOne(
  { title: "Захар Беркут" },
  { $unset: { temporary_note: "" } }
);
```

**Операції видалення:**

```javascript
// Видалення одного документа
db.books.deleteOne({ title: "Застарілий довідник" });

// Видалення за умовою
db.books.deleteMany({ available: false, publication_year: { $lt: 1850 } });

// Видалення користувача з призупиненим статусом
db.users.deleteOne({ status: "suspended", username: "old_user" });
```

### Крок 6. Створення індексів

```javascript
// Простий індекс для швидкого пошуку за назвою
db.books.createIndex({ title: 1 });

// Складений індекс для пошуку за автором та роком
db.books.createIndex({ author: 1, publication_year: -1 });

// Унікальний індекс для ISBN
db.books.createIndex({ isbn: 1 }, { unique: true });

// Перевірка списку індексів
db.books.getIndexes();

// Аналіз використання індексів
db.books.find({ author: "Тарас Шевченко" }).explain("executionStats");
```

Порівняйте час виконання запиту до та після створення індексів:

```javascript
// Без індексу
db.books.find({ author: "Іван Франко" }).explain("executionStats");

// Створення індексу
db.books.createIndex({ author: 1 });

// З індексом
db.books.find({ author: "Іван Франко" }).explain("executionStats");
```

### Крок 7. Агрегаційні запити (рівень 2)

```javascript
// Підрахунок книг за жанрами
db.books.aggregate([
  { $unwind: "$genres" },
  { $group: { _id: "$genres", count: { $sum: 1 } } },
  { $sort: { count: -1 } }
]);

// Середня кількість сторінок за автором
db.books.aggregate([
  {
    $group: {
      _id: "$author",
      avg_pages: { $avg: "$pages" },
      total_books: { $sum: 1 }
    }
  },
  { $sort: { avg_pages: -1 } }
]);

// Статистика по століттях
db.books.aggregate([
  {
    $project: {
      title: 1,
      author: 1,
      century: { $ceil: { $divide: ["$publication_year", 100] } }
    }
  },
  {
    $group: {
      _id: "$century",
      books_count: { $sum: 1 },
      authors: { $addToSet: "$author" }
    }
  }
]);

// Топ користувачів за кількістю взятих книг
db.users.aggregate([
  {
    $project: {
      username: 1,
      email: 1,
      borrowed_count: { $size: "$borrowed_books" }
    }
  },
  { $sort: { borrowed_count: -1 } },
  { $limit: 5 }
]);
```

### Крок 8. Об'єднання колекцій з $lookup

```javascript
// Спочатку додамо author_id до книг
db.authors.find().forEach(function(author) {
  db.books.updateMany(
    { author: author.name },
    { $set: { author_id: author._id } }
  );
});

// Тепер виконаємо lookup
db.books.aggregate([
  {
    $lookup: {
      from: "authors",
      localField: "author_id",
      foreignField: "_id",
      as: "author_details"
    }
  },
  { $unwind: "$author_details" },
  {
    $project: {
      title: 1,
      "author_details.name": 1,
      "author_details.birth_year": 1,
      publication_year: 1,
      pages: 1
    }
  }
]);
```

### Крок 9. Текстовий пошук

```javascript
// Створення текстового індексу
db.books.createIndex({ title: "text", description: "text" });

// Пошук за ключовими словами
db.books.find({ $text: { $search: "кохання Карпати" } });

// Пошук з оцінкою релевантності
db.books.find(
  { $text: { $search: "український письменник" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } });
```

### Крок 10. Валідація схеми (рівень 3)

```javascript
// Модифікація колекції з додаванням валідації
db.runCommand({
  collMod: "books",
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "publication_year", "available"],
      properties: {
        title: {
          bsonType: "string",
          minLength: 1,
          maxLength: 200,
          description: "Назва книги обов'язкова, від 1 до 200 символів"
        },
        author: {
          bsonType: "string",
          minLength: 1,
          description: "Автор обов'язковий"
        },
        publication_year: {
          bsonType: "int",
          minimum: 1000,
          maximum: 2100,
          description: "Рік видання має бути між 1000 та 2100"
        },
        pages: {
          bsonType: "int",
          minimum: 1,
          maximum: 10000,
          description: "Кількість сторінок має бути додатнім числом"
        },
        isbn: {
          bsonType: "string",
          pattern: "^978-\\d{1,5}-\\d{1,7}-\\d{1,7}-\\d{1}$",
          description: "ISBN має відповідати стандартному формату"
        },
        available: {
          bsonType: "bool",
          description: "Доступність обов'язкова"
        }
      }
    }
  },
  validationLevel: "strict"
});

// Спроба вставити некоректний документ (має бути відхилена)
db.books.insertOne({
  title: "Тестова книга",
  author: "Тестовий автор",
  publication_year: 3000, // Некоректний рік
  available: true
});
```

### Крок 11. Резервне копіювання

```bash
# Створення резервної копії всієї бази даних
mongodump --db library --out /backup/library_backup

# Створення резервної копії конкретної колекції
mongodump --db library --collection books --out /backup/books_backup

# Відновлення з резервної копії
mongorestore --db library /backup/library_backup/library

# Експорт в JSON формат
mongoexport --db library --collection books --out books.json --pretty

# Імпорт з JSON
mongoimport --db library --collection books --file books.json --jsonArray
```

### Крок 12. Порівняльний аналіз (рівень 3)

Створіть документ з порівнянням реляційного та документного підходів для бібліотечної системи:

**Реляційний підхід (PostgreSQL):**

```sql
-- Структура таблиць
CREATE TABLE authors (
    author_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    birth_year INT,
    nationality VARCHAR(50)
);

CREATE TABLE books (
    book_id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author_id INT REFERENCES authors(author_id),
    publication_year INT,
    pages INT,
    available BOOLEAN DEFAULT TRUE
);

CREATE TABLE genres (
    genre_id SERIAL PRIMARY KEY,
    genre_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE book_genres (
    book_id INT REFERENCES books(book_id),
    genre_id INT REFERENCES genres(genre_id),
    PRIMARY KEY (book_id, genre_id)
);

-- Запит з JOIN
SELECT b.title, a.name, g.genre_name
FROM books b
JOIN authors a ON b.author_id = a.author_id
JOIN book_genres bg ON b.book_id = bg.book_id
JOIN genres g ON bg.genre_id = g.genre_id
WHERE b.available = TRUE;
```

**Документний підхід (MongoDB):**

```javascript
// Одна колекція з вкладеними документами
{
  _id: ObjectId("..."),
  title: "Кобзар",
  author: {
    name: "Тарас Шевченко",
    birth_year: 1814,
    nationality: "український"
  },
  genres: ["поезія", "романтизм"],
  publication_year: 1840,
  pages: 238,
  available: true
}

// Запит без JOIN
db.books.find({ available: true });
```

**Порівняння:**

| Аспект | Реляційний підхід | Документний підхід |
|--------|-------------------|-------------------|
| Нормалізація | Висока, розділення на таблиці | Денормалізація, вкладені документи |
| Запити | Складні JOIN операції | Прості запити без об'єднань |
| Гнучкість схеми | Жорстка, потребує міграцій | Гнучка, динамічна схема |
| Масштабованість | Вертикальна (складніше) | Горизонтальна (простіше) |
| Транзакції | ACID гарантії | Обмежена підтримка ACID |
| Продуктивність читання | Залежить від JOIN | Швидше при денормалізації |
| Продуктивність запису | Швидше при нормалізації | Може бути повільніше через дублювання |

## Критерії оцінювання

### Рівень 1 (35-49 балів)

- Успішне встановлення та налаштування MongoDB (4 бали).
- Створення бази даних з трьома колекціями (8 балів).
- Додавання по 10 документів у кожну колекцію (12 балів).
- Виконання базових CRUD операцій (вставка, пошук, оновлення, видалення) (15 балів).
- Створення трьох різних індексів (4 бали).
- Порівняння продуктивності запитів з індексами та без них (4 бали).

### Рівень 2 (50-74 балів)

Усі завдання рівня 1 плюс:

- Реалізація складних запитів з логічними операторами (4 бали).
- Виконання агрегаційних запитів з використанням pipeline (8 балів).
- Створення складених індексів для оптимізації (3 бали).
- Реалізація текстового пошуку з text індексом (4 бали).
- Використання $lookup для об'єднання колекцій (4 бали).
- Створення представлення для складних запитів (2 бали).

### Рівень 3 (75-100 балів)

Усі завдання рівня 2 плюс:

- Реалізація валідації схеми з JSON Schema (5 балів).
- Створення геопросторових індексів або TTL індексів (3 бали).
- Розробка системи версіонування документів (4 бали).
- Повнотекстовий пошук з підтримкою української мови (3 бали).
- Налаштування реплікації або шардингу (якщо можливо) (3 бали).
- Автоматизоване резервне копіювання з mongodump (3 бали).
- Детальний порівняльний аналіз реляційного та документного підходів (4 бали).

## Контрольні запитання

1. У чому полягають основні відмінності між реляційними та документо-орієнтованими базами даних? Коли доцільно використовувати кожен підхід?
2. Що таке BSON і чим він відрізняється від JSON? Які переваги надає використання BSON у MongoDB?
3. Поясніть концепцію денормалізації в контексті NoSQL баз даних. Які переваги та недоліки цього підходу?
4. Як працює агрегаційний pipeline в MongoDB? Опишіть основні етапи та їх призначення.
5. Що таке індекси в MongoDB і як вони впливають на продуктивність запитів? Які типи індексів підтримує MongoDB?
6. Поясніть різницю між операторами `updateOne`, `updateMany` та `replaceOne`. Коли використовувати кожен з них?
7. Що таке валідація схеми в MongoDB і як вона реалізується через JSON Schema?
8. Як реалізувати зв'язки між документами в MongoDB? Порівняйте підходи з вбудованими документами та посиланнями.
9. Що таке текстовий індекс і як він використовується для повнотекстового пошуку?
10. Опишіть стратегії масштабування MongoDB. Що таке sharding і реплікація?

---

# Лабораторна робота 7. Повний цикл розробки NoSQL застосунку з інтеграцією

## Тема

Система управління контентом (блог) на базі MongoDB з вебінтерфейсом

## Мета

Застосувати знання роботи з NoSQL базами даних для створення повноцінного вебзастосунку, навчитися проєктувати документні схеми для реальних предметних областей, опанувати інтеграцію MongoDB з фронтенд технологіями, розвинути навички аналізу та оптимізації продуктивності документо-орієнтованих систем.

## Завдання

### Рівень 1 (обов'язковий мінімум)

1. Спроєктувати схему документів для блог-системи з колекціями:
    - `users` (користувачі з ролями: автор, читач, адміністратор)
    - `posts` (статті з вбудованими коментарями та метаданими)
    - `categories` (категорії та теги)
2. Створити колекції з валідацією схеми для забезпечення цілісності даних.
3. Заповнити базу даних реалістичними даними:
    - Мінімум 50 постів
    - Мінімум 200 коментарів
    - 20 користувачів
    - 10 категорій
4. Розробити агрегаційні запити для:
    - Топ 10 авторів за кількістю постів
    - Популярні категорії за кількістю постів
    - Статистика коментарів (загальна, середня на пост)
5. Створити індекси для оптимізації пошуку постів за автором, категорією та датою.
6. Реалізувати простий HTML інтерфейс з JavaScript для відображення списку постів та детальної інформації.

### Рівень 2 (додаткова функціональність)

Додатково до рівня 1:

1. Реалізувати систему тегів з можливістю пошуку постів за множинними тегами.
2. Додати повнотекстовий пошук за назвою та змістом постів.
3. Створити систему рейтингів постів з можливістю лайків/дизлайків.
4. Реалізувати пагінацію для списку постів через агрегаційний pipeline.
5. Додати статистику переглядів постів з інкрементацією лічильників.
6. Створити систему модерації коментарів з статусами (очікує перевірки, схвалено, відхилено).
7. Реалізувати вебінтерфейс з можливістю додавання нових постів через форму.

### Рівень 3 (творче розширення)

Додатково до рівня 2:

1. Розробити систему версіонування постів з збереженням історії редагувань.
2. Реалізувати вкладені коментарі (відповіді на коментарі) з рекурсивною структурою.
3. Створити систему сповіщень для авторів про нові коментарі під їх постами.
4. Додати геолокацію для постів з можливістю пошуку за координатами.
5. Реалізувати аналітичну панель з візуалізацією статистики через графіки.
6. Створити RESTful API для взаємодії з системою через HTTP запити.
7. Додати систему кешування популярних запитів для підвищення продуктивності.
8. Розробити порівняльний аналіз з еквівалентною реляційною схемою та тестами продуктивності.

## Теоретичні відомості

### Проєктування документних схем

Проєктування схеми в NoSQL вимагає іншого підходу порівняно з реляційними базами даних. Замість нормалізації та розбиття на таблиці, документний підхід фокусується на патернах доступу до даних та оптимізації для найпоширеніших запитів.

**Основні принципи проєктування:**

**Модель "один до кількох" — вбудовані документи:**

Коли одна сутність тісно пов'язана з іншою та завжди отримується разом, краще вбудовувати дані в один документ.

```javascript
// Пост з вбудованими коментарями
{
  _id: ObjectId("..."),
  title: "Вступ до NoSQL",
  content: "Текст статті...",
  author: {
    user_id: ObjectId("..."),
    username: "ivan_developer",
    avatar: "avatar.jpg"
  },
  comments: [
    {
      comment_id: ObjectId("..."),
      author: {
        user_id: ObjectId("..."),
        username: "maria_reader"
      },
      text: "Чудова стаття!",
      created_at: ISODate("2024-03-15T10:30:00Z")
    }
  ],
  tags: ["mongodb", "nosql", "database"],
  created_at: ISODate("2024-03-10T12:00:00Z"),
  updated_at: ISODate("2024-03-10T12:00:00Z")
}
```

**Модель "багато до багатьох" — посилання:**

Коли сутності мають складні зв'язки або використовуються незалежно, краще зберігати посилання.

```javascript
// Пост з посиланням на автора
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  title: "Архітектура мікросервісів",
  author_id: ObjectId("507f1f77bcf86cd799439012"),
  category_ids: [
    ObjectId("507f1f77bcf86cd799439013"),
    ObjectId("507f1f77bcf86cd799439014")
  ]
}

// Окремий документ користувача
{
  _id: ObjectId("507f1f77bcf86cd799439012"),
  username: "ivan_developer",
  email: "ivan@example.com",
  role: "author"
}
```

**Гібридний підхід:**

Часто оптимально поєднувати обидва підходи, вбудовуючи найважливіші дані та зберігаючи посилання для детальної інформації.

```javascript
{
  _id: ObjectId("..."),
  title: "Сучасний JavaScript",
  author: {
    id: ObjectId("..."),
    username: "ivan_developer",
    // Основна інформація вбудована для швидкого доступу
  },
  category: {
    id: ObjectId("..."),
    name: "Веброзробка"
  },
  comments_count: 42,
  // Самі коментарі можуть бути в окремій колекції для великої кількості
}
```

### Патерни проєктування документних схем

**Патерн "Bucket":**

Використовується для зберігання часових рядів або подій, групуючи їх в бакети за періодами.

```javascript
{
  _id: ObjectId("..."),
  post_id: ObjectId("..."),
  month: "2024-03",
  views: [
    { date: ISODate("2024-03-01"), count: 150 },
    { date: ISODate("2024-03-02"), count: 230 },
    // ... інші дні місяця
  ],
  total_views: 4580
}
```

**Патерн "Computed":**

Попереднє обчислення та зберігання агрегованих даних для швидкого доступу.

```javascript
{
  _id: ObjectId("..."),
  author_id: ObjectId("..."),
  statistics: {
    total_posts: 47,
    total_comments: 312,
    total_likes: 1205,
    avg_likes_per_post: 25.6,
    last_updated: ISODate("2024-03-20T10:00:00Z")
  }
}
```

**Патерн "Polymorphic":**

Зберігання документів різних типів в одній колекції з полем-дискримінатором.

```javascript
// Пост-стаття
{
  _id: ObjectId("..."),
  type: "article",
  title: "...",
  content: "...",
  author_id: ObjectId("...")
}

// Пост-відео
{
  _id: ObjectId("..."),
  type: "video",
  title: "...",
  video_url: "...",
  duration: 360,
  author_id: ObjectId("...")
}
```

### Інтеграція MongoDB з вебзастосунками

**Підключення через Node.js Driver:**

```javascript
const { MongoClient } = require('mongodb');

// URL підключення
const url = 'mongodb://localhost:27017';
const client = new MongoClient(url);

// Підключення до бази даних
async function connectDB() {
  try {
    await client.connect();
    console.log('Connected to MongoDB');
    const db = client.db('blog_system');
    return db;
  } catch (error) {
    console.error('Connection error:', error);
  }
}

// Приклад запиту
async function getRecentPosts(limit = 10) {
  const db = await connectDB();
  const posts = await db.collection('posts')
    .find({})
    .sort({ created_at: -1 })
    .limit(limit)
    .toArray();
  return posts;
}
```

**Використання з вебфреймворком Express.js:**

```javascript
const express = require('express');
const { MongoClient } = require('mongodb');

const app = express();
const url = 'mongodb://localhost:27017';
const client = new MongoClient(url);

let db;

// Підключення до БД при старті сервера
client.connect().then(() => {
  db = client.db('blog_system');
  console.log('Connected to MongoDB');
});

// API endpoint для отримання постів
app.get('/api/posts', async (req, res) => {
  try {
    const posts = await db.collection('posts')
      .find({})
      .sort({ created_at: -1 })
      .limit(10)
      .toArray();
    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// API endpoint для створення посту
app.post('/api/posts', express.json(), async (req, res) => {
  try {
    const { title, content, author_id } = req.body;
    const result = await db.collection('posts').insertOne({
      title,
      content,
      author_id: new ObjectId(author_id),
      created_at: new Date(),
      comments: [],
      likes: 0,
      views: 0
    });
    res.status(201).json({ id: result.insertedId });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### Оптимізація продуктивності

**Стратегії індексування:**

```javascript
// Складений індекс для сортування та фільтрації
db.posts.createIndex({ category_id: 1, created_at: -1 });

// Текстовий індекс для пошуку
db.posts.createIndex({ title: "text", content: "text" });

// Унікальний індекс
db.users.createIndex({ email: 1 }, { unique: true });

// Часткові індекси для опублікованих постів
db.posts.createIndex(
  { created_at: -1 },
  { partialFilterExpression: { status: "published" } }
);
```

**Projection для обмеження полів:**

```javascript
// Отримання тільки необхідних полів
db.posts.find(
  { category_id: categoryId },
  { title: 1, author: 1, created_at: 1, _id: 1 }
);

// Виключення великих полів
db.posts.find(
  {},
  { content: 0, comments: 0 }
);
```

**Пагінація з skip та limit:**

```javascript
// Проста пагінація (не рекомендується для великих offset)
const page = 2;
const perPage = 20;
db.posts.find()
  .skip((page - 1) * perPage)
  .limit(perPage)
  .toArray();

// Краща пагінація через курсор
const lastId = ObjectId("...");
db.posts.find({ _id: { $gt: lastId } })
  .limit(20)
  .toArray();
```

## Хід роботи

### Крок 1. Проєктування схеми бази даних

Створіть документ з детальним описом схеми для кожної колекції.

**Колекція `users`:**

```javascript
{
  _id: ObjectId,
  username: String (унікальний, 3-30 символів),
  email: String (унікальний, валідний email),
  password_hash: String (хеш пароля),
  role: String (enum: "admin", "author", "reader"),
  profile: {
    full_name: String,
    bio: String,
    avatar_url: String,
    website: String
  },
  statistics: {
    posts_count: Number (для авторів),
    comments_count: Number
  },
  created_at: Date,
  last_login: Date,
  status: String (enum: "active", "suspended", "deleted")
}
```

**Колекція `posts`:**

```javascript
{
  _id: ObjectId,
  title: String (3-200 символів),
  slug: String (унікальний URL-friendly ідентифікатор),
  content: String (текст статті),
  excerpt: String (короткий опис),
  author: {
    user_id: ObjectId,
    username: String,
    avatar_url: String
  },
  category: {
    category_id: ObjectId,
    name: String
  },
  tags: [String] (масив тегів),
  featured_image: String (URL зображення),
  status: String (enum: "draft", "published", "archived"),
  comments: [
    {
      comment_id: ObjectId,
      author: {
        user_id: ObjectId,
        username: String
      },
      text: String,
      created_at: Date,
      status: String (enum: "pending", "approved", "rejected"),
      likes: Number
    }
  ],
  statistics: {
    views: Number,
    likes: Number,
    comments_count: Number
  },
  created_at: Date,
  updated_at: Date,
  published_at: Date
}
```

**Колекція `categories`:**

```javascript
{
  _id: ObjectId,
  name: String (унікальна назва),
  slug: String (URL-friendly назва),
  description: String,
  parent_id: ObjectId (для вкладених категорій),
  statistics: {
    posts_count: Number
  },
  created_at: Date
}
```

### Крок 2. Створення колекцій з валідацією

```javascript
// Підключення до бази даних
use blog_system

// Створення колекції користувачів
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["username", "email", "password_hash", "role", "created_at"],
      properties: {
        username: {
          bsonType: "string",
          minLength: 3,
          maxLength: 30,
          description: "Ім'я користувача має бути рядком від 3 до 30 символів"
        },
        email: {
          bsonType: "string",
          pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
          description: "Email має відповідати стандартному формату"
        },
        password_hash: {
          bsonType: "string",
          minLength: 60,
          description: "Хеш пароля обов'язковий"
        },
        role: {
          enum: ["admin", "author", "reader"],
          description: "Роль має бути одна з: admin, author, reader"
        },
        status: {
          enum: ["active", "suspended", "deleted"],
          description: "Статус користувача"
        },
        created_at: {
          bsonType: "date",
          description: "Дата створення обов'язкова"
        }
      }
    }
  }
});

// Створення колекції постів
db.createCollection("posts", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "content", "author", "created_at", "status"],
      properties: {
        title: {
          bsonType: "string",
          minLength: 3,
          maxLength: 200,
          description: "Назва має бути від 3 до 200 символів"
        },
        slug: {
          bsonType: "string",
          pattern: "^[a-z0-9-]+$",
          description: "Slug має містити тільки малі літери, цифри та дефіси"
        },
        content: {
          bsonType: "string",
          minLength: 100,
          description: "Контент має містити мінімум 100 символів"
        },
        author: {
          bsonType: "object",
          required: ["user_id", "username"],
          properties: {
            user_id: { bsonType: "objectId" },
            username: { bsonType: "string" }
          }
        },
        status: {
          enum: ["draft", "published", "archived"],
          description: "Статус посту"
        },
        created_at: {
          bsonType: "date"
        }
      }
    }
  }
});

// Створення колекції категорій
db.createCollection("categories", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "slug", "created_at"],
      properties: {
        name: {
          bsonType: "string",
          minLength: 2,
          maxLength: 50
        },
        slug: {
          bsonType: "string",
          pattern: "^[a-z0-9-]+$"
        },
        created_at: {
          bsonType: "date"
        }
      }
    }
  }
});
```

### Крок 3. Створення унікальних індексів

```javascript
// Індекси для користувачів
db.users.createIndex({ username: 1 }, { unique: true });
db.users.createIndex({ email: 1 }, { unique: true });
db.users.createIndex({ created_at: -1 });

// Індекси для постів
db.posts.createIndex({ slug: 1 }, { unique: true });
db.posts.createIndex({ "author.user_id": 1, created_at: -1 });
db.posts.createIndex({ "category.category_id": 1, status: 1 });
db.posts.createIndex({ status: 1, published_at: -1 });
db.posts.createIndex({ tags: 1 });
db.posts.createIndex({ title: "text", content: "text", excerpt: "text" });

// Індекси для категорій
db.categories.createIndex({ slug: 1 }, { unique: true });
db.categories.createIndex({ name: 1 }, { unique: true });
```

### Крок 4. Заповнення тестовими даними

```javascript
// Функція для генерації випадкових користувачів
function generateUsers(count) {
  const roles = ["admin", "author", "reader"];
  const users = [];

  for (let i = 0; i < count; i++) {
    users.push({
      username: `user${i + 1}`,
      email: `user${i + 1}@blog.com`,
      password_hash: "$2a$10$example_hash_for_testing_purposes_only",
      role: roles[Math.floor(Math.random() * roles.length)],
      profile: {
        full_name: `Користувач ${i + 1}`,
        bio: `Біографія користувача ${i + 1}`,
        avatar_url: `https://api.dicebear.com/7.x/avataaars/svg?seed=${i}`,
        website: i % 3 === 0 ? `https://user${i + 1}.com` : null
      },
      statistics: {
        posts_count: 0,
        comments_count: 0
      },
      created_at: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000),
      last_login: new Date(),
      status: "active"
    });
  }

  return users;
}

// Вставка користувачів
const users = generateUsers(20);
db.users.insertMany(users);

// Отримання ID авторів для постів
const authors = db.users.find({ role: "author" }).toArray();

// Генерація категорій
const categories = [
  { name: "Веброзробка", slug: "web-development", description: "Статті про веброзробку" },
  { name: "Мобільні додатки", slug: "mobile-apps", description: "Розробка мобільних додатків" },
  { name: "Бази даних", slug: "databases", description: "NoSQL та SQL бази даних" },
  { name: "DevOps", slug: "devops", description: "Автоматизація та CI/CD" },
  { name: "Штучний інтелект", slug: "ai", description: "ML та AI технології" },
  { name: "Хмарні технології", slug: "cloud", description: "AWS, Azure, Google Cloud" },
  { name: "Безпека", slug: "security", description: "Кібербезпека та захист даних" },
  { name: "UX/UI", slug: "ux-ui", description: "Дизайн інтерфейсів" },
  { name: "Архітектура ПЗ", slug: "architecture", description: "Patterns та Best Practices" },
  { name: "Тестування", slug: "testing", description: "Методології тестування" }
];

categories.forEach(cat => {
  cat.created_at = new Date();
  cat.statistics = { posts_count: 0 };
});

db.categories.insertMany(categories);

// Генерація постів
function generatePosts(count, authors, categories) {
  const tags = [
    "javascript", "python", "mongodb", "react", "nodejs",
    "docker", "kubernetes", "aws", "typescript", "vue"
  ];
  const posts = [];

  for (let i = 0; i < count; i++) {
    const author = authors[Math.floor(Math.random() * authors.length)];
    const category = categories[Math.floor(Math.random() * categories.length)];
    const postTags = [];
    const tagsCount = Math.floor(Math.random() * 3) + 1;

    for (let j = 0; j < tagsCount; j++) {
      const tag = tags[Math.floor(Math.random() * tags.length)];
      if (!postTags.includes(tag)) postTags.push(tag);
    }

    const createdDate = new Date(Date.now() - Math.random() * 180 * 24 * 60 * 60 * 1000);

    posts.push({
      title: `Стаття ${i + 1}: Цікава тема про програмування`,
      slug: `article-${i + 1}-programming-topic`,
      content: `Це детальний контент статті номер ${i + 1}. Тут розглядаються важливі аспекти сучасної розробки програмного забезпечення. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.`,
      excerpt: `Короткий опис статті ${i + 1}`,
      author: {
        user_id: author._id,
        username: author.username,
        avatar_url: author.profile.avatar_url
      },
      category: {
        category_id: category._id,
        name: category.name
      },
      tags: postTags,
      featured_image: `https://picsum.photos/800/400?random=${i}`,
      status: "published",
      comments: [],
      statistics: {
        views: Math.floor(Math.random() * 1000),
        likes: Math.floor(Math.random() * 100),
        comments_count: 0
      },
      created_at: createdDate,
      updated_at: createdDate,
      published_at: createdDate
    });
  }

  return posts;
}

const categoryDocs = db.categories.find().toArray();
const posts = generatePosts(50, authors, categoryDocs);
db.posts.insertMany(posts);

// Генерація коментарів
const allPosts = db.posts.find().toArray();
const allUsers = db.users.find().toArray();

allPosts.forEach(post => {
  const commentsCount = Math.floor(Math.random() * 8) + 1;
  const comments = [];

  for (let i = 0; i < commentsCount; i++) {
    const commentAuthor = allUsers[Math.floor(Math.random() * allUsers.length)];
    comments.push({
      comment_id: new ObjectId(),
      author: {
        user_id: commentAuthor._id,
        username: commentAuthor.username
      },
      text: `Це коментар ${i + 1} до статті. Дуже цікава думка про тему.`,
      created_at: new Date(post.created_at.getTime() + Math.random() * 30 * 24 * 60 * 60 * 1000),
      status: "approved",
      likes: Math.floor(Math.random() * 20)
    });
  }

  db.posts.updateOne(
    { _id: post._id },
    {
      $set: { comments: comments },
      $inc: { "statistics.comments_count": comments.length }
    }
  );
});
```

### Крок 5. Розробка агрегаційних запитів

```javascript
// Топ 10 авторів за кількістю постів
db.posts.aggregate([
  { $match: { status: "published" } },
  {
    $group: {
      _id: "$author.user_id",
      username: { $first: "$author.username" },
      posts_count: { $sum: 1 },
      total_views: { $sum: "$statistics.views" },
      total_likes: { $sum: "$statistics.likes" }
    }
  },
  { $sort: { posts_count: -1 } },
  { $limit: 10 },
  {
    $project: {
      _id: 0,
      author_id: "$_id",
      username: 1,
      posts_count: 1,
      total_views: 1,
      total_likes: 1,
      avg_views_per_post: { $divide: ["$total_views", "$posts_count"] }
    }
  }
]);

// Популярні категорії
db.posts.aggregate([
  { $match: { status: "published" } },
  {
    $group: {
      _id: "$category.category_id",
      category_name: { $first: "$category.name" },
      posts_count: { $sum: 1 },
      total_views: { $sum: "$statistics.views" },
      avg_likes: { $avg: "$statistics.likes" }
    }
  },
  { $sort: { posts_count: -1 } },
  {
    $project: {
      _id: 0,
      category_name: 1,
      posts_count: 1,
      total_views: 1,
      avg_likes: { $round: ["$avg_likes", 2] }
    }
  }
]);

// Статистика коментарів
db.posts.aggregate([
  { $match: { status: "published" } },
  {
    $project: {
      title: 1,
      author: 1,
      comments_count: "$statistics.comments_count",
      views: "$statistics.views"
    }
  },
  {
    $group: {
      _id: null,
      total_posts: { $sum: 1 },
      total_comments: { $sum: "$comments_count" },
      avg_comments_per_post: { $avg: "$comments_count" },
      max_comments: { $max: "$comments_count" }
    }
  },
  {
    $project: {
      _id: 0,
      total_posts: 1,
      total_comments: 1,
      avg_comments_per_post: { $round: ["$avg_comments_per_post", 2] },
      max_comments: 1
    }
  }
]);

// Розподіл постів за тегами
db.posts.aggregate([
  { $match: { status: "published" } },
  { $unwind: "$tags" },
  {
    $group: {
      _id: "$tags",
      count: { $sum: 1 },
      avg_views: { $avg: "$statistics.views" }
    }
  },
  { $sort: { count: -1 } },
  { $limit: 10 },
  {
    $project: {
      _id: 0,
      tag: "$_id",
      posts_count: "$count",
      avg_views: { $round: ["$avg_views", 0] }
    }
  }
]);
```

### Крок 6. Створення HTML інтерфейсу

Створіть файл `index.html`:

```html
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Блог на MongoDB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f4f4f4;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 1rem 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        h1 {
            font-size: 2rem;
        }

        .search-bar {
            margin: 2rem 0;
            display: flex;
            gap: 1rem;
        }

        .search-bar input {
            flex: 1;
            padding: 0.8rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .search-bar button {
            padding: 0.8rem 1.5rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }

        .search-bar button:hover {
            background: #2980b9;
        }

        .posts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .post-card {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
        }

        .post-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .post-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .post-content {
            padding: 1.5rem;
        }

        .post-title {
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .post-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: #7f8c8d;
            margin-bottom: 1rem;
        }

        .post-excerpt {
            color: #555;
            margin-bottom: 1rem;
        }

        .post-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .tag {
            background: #ecf0f1;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #2c3e50;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .modal-content {
            position: relative;
            background: white;
            width: 90%;
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            border-radius: 8px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2rem;
            cursor: pointer;
            color: #7f8c8d;
        }

        .comments {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #ecf0f1;
        }

        .comment {
            padding: 1rem;
            background: #f8f9fa;
            margin-bottom: 1rem;
            border-radius: 4px;
        }

        .comment-author {
            font-weight: bold;
            color: #2c3e50;
        }

        .comment-date {
            font-size: 0.85rem;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>📝 Блог на MongoDB</h1>
        </div>
    </header>

    <div class="container">
        <div class="search-bar">
            <input type="text" id="searchInput" placeholder="Пошук статей...">
            <button onclick="searchPosts()">Шукати</button>
        </div>

        <div id="postsGrid" class="posts-grid">
            <!-- Пости будуть завантажені тут -->
        </div>
    </div>

    <div id="postModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal()">&times;</span>
            <div id="postDetails"></div>
        </div>
    </div>

    <script>
        // Симуляція даних з MongoDB (у реальному проєкті використовуйте API)
        const mockPosts = [
            {
                _id: "1",
                title: "Вступ до NoSQL баз даних",
                excerpt: "Детальний огляд переваг NoSQL над традиційними SQL базами даних",
                author: { username: "ivan_developer", avatar_url: "https://api.dicebear.com/7.x/avataaars/svg?seed=1" },
                category: { name: "Бази даних" },
                tags: ["nosql", "mongodb", "database"],
                featured_image: "https://picsum.photos/800/400?random=1",
                statistics: { views: 542, likes: 34, comments_count: 12 },
                created_at: "2024-03-15",
                content: "Повний текст статті про NoSQL бази даних...",
                comments: [
                    { author: { username: "maria_reader" }, text: "Чудова стаття!", created_at: "2024-03-16" },
                    { author: { username: "user3" }, text: "Дуже корисно", created_at: "2024-03-17" }
                ]
            },
            {
                _id: "2",
                title: "React Hooks: Повний гайд",
                excerpt: "Все що потрібно знати про React Hooks для сучасної розробки",
                author: { username: "maria_frontend", avatar_url: "https://api.dicebear.com/7.x/avataaars/svg?seed=2" },
                category: { name: "Веброзробка" },
                tags: ["react", "javascript", "frontend"],
                featured_image: "https://picsum.photos/800/400?random=2",
                statistics: { views: 821, likes: 67, comments_count: 23 },
                created_at: "2024-03-10",
                content: "Детальний розбір React Hooks...",
                comments: [
                    { author: { username: "developer123" }, text: "Дуже допомогло!", created_at: "2024-03-11" }
                ]
            },
            {
                _id: "3",
                title: "Docker для початківців",
                excerpt: "Основи контейнеризації та роботи з Docker",
                author: { username: "oleksandr_devops", avatar_url: "https://api.dicebear.com/7.x/avataaars/svg?seed=3" },
                category: { name: "DevOps" },
                tags: ["docker", "devops", "containers"],
                featured_image: "https://picsum.photos/800/400?random=3",
                statistics: { views: 634, likes: 45, comments_count: 18 },
                created_at: "2024-03-05",
                content: "Вступ до Docker та контейнеризації...",
                comments: []
            }
        ];

        // Завантаження постів
        function loadPosts(posts = mockPosts) {
            const grid = document.getElementById('postsGrid');
            grid.innerHTML = '';

            posts.forEach(post => {
                const card = createPostCard(post);
                grid.appendChild(card);
            });
        }

        // Створення картки посту
        function createPostCard(post) {
            const card = document.createElement('div');
            card.className = 'post-card';
            card.onclick = () => showPostDetails(post);

            card.innerHTML = `
                <img src="${post.featured_image}" alt="${post.title}">
                <div class="post-content">
                    <h2 class="post-title">${post.title}</h2>
                    <div class="post-meta">
                        <span>👤 ${post.author.username}</span>
                        <span>📁 ${post.category.name}</span>
                        <span>👁️ ${post.statistics.views}</span>
                    </div>
                    <p class="post-excerpt">${post.excerpt}</p>
                    <div class="post-tags">
                        ${post.tags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                    </div>
                </div>
            `;

            return card;
        }

        // Відображення деталей посту
        function showPostDetails(post) {
            const modal = document.getElementById('postModal');
            const details = document.getElementById('postDetails');

            details.innerHTML = `
                <img src="${post.featured_image}" alt="${post.title}" style="width: 100%; border-radius: 8px; margin-bottom: 1rem;">
                <h2>${post.title}</h2>
                <div class="post-meta" style="margin: 1rem 0;">
                    <span>👤 ${post.author.username}</span>
                    <span>📁 ${post.category.name}</span>
                    <span>📅 ${post.created_at}</span>
                    <span>👁️ ${post.statistics.views}</span>
                    <span>❤️ ${post.statistics.likes}</span>
                </div>
                <div class="post-tags" style="margin-bottom: 1.5rem;">
                    ${post.tags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                </div>
                <p>${post.content}</p>
                <div class="comments">
                    <h3>Коментарі (${post.comments.length})</h3>
                    ${post.comments.map(comment => `
                        <div class="comment">
                            <div class="comment-author">${comment.author.username}</div>
                            <div class="comment-date">${comment.created_at}</div>
                            <p>${comment.text}</p>
                        </div>
                    `).join('')}
                </div>
            `;

            modal.style.display = 'block';
        }

        // Закриття модального вікна
        function closeModal() {
            document.getElementById('postModal').style.display = 'none';
        }

        // Пошук постів
        function searchPosts() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const filtered = mockPosts.filter(post =>
                post.title.toLowerCase().includes(searchTerm) ||
                post.excerpt.toLowerCase().includes(searchTerm) ||
                post.tags.some(tag => tag.includes(searchTerm))
            );
            loadPosts(filtered);
        }

        // Закриття модального вікна при кліку поза ним
        window.onclick = function(event) {
            const modal = document.getElementById('postModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        // Завантаження при старті
        loadPosts();
    </script>
</body>
</html>
```

### Крок 7. Порівняльний аналіз (рівень 3)

Створіть документ з порівнянням реляційної та документної моделі для блог-системи.

**Реляційна схема (PostgreSQL):**

```sql
-- Таблиця користувачів
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(30) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Таблиця категорій
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    slug VARCHAR(50) UNIQUE NOT NULL,
    description TEXT
);

-- Таблиця постів
CREATE TABLE posts (
    post_id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    slug VARCHAR(200) UNIQUE NOT NULL,
    content TEXT NOT NULL,
    excerpt TEXT,
    user_id INT REFERENCES users(user_id),
    category_id INT REFERENCES categories(category_id),
    status VARCHAR(20) NOT NULL,
    views INT DEFAULT 0,
    likes INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    published_at TIMESTAMP
);

-- Таблиця тегів
CREATE TABLE tags (
    tag_id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL
);

-- Зв'язок постів і тегів
CREATE TABLE post_tags (
    post_id INT REFERENCES posts(post_id),
    tag_id INT REFERENCES tags(tag_id),
    PRIMARY KEY (post_id, tag_id)
);

-- Таблиця коментарів
CREATE TABLE comments (
    comment_id SERIAL PRIMARY KEY,
    post_id INT REFERENCES posts(post_id),
    user_id INT REFERENCES users(user_id),
    text TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);

-- Складний запит для отримання посту з коментарями
SELECT
    p.post_id,
    p.title,
    p.content,
    u.username as author,
    c.name as category,
    array_agg(DISTINCT t.name) as tags,
    COUNT(DISTINCT cm.comment_id) as comments_count
FROM posts p
JOIN users u ON p.user_id = u.user_id
JOIN categories c ON p.category_id = c.category_id
LEFT JOIN post_tags pt ON p.post_id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.tag_id
LEFT JOIN comments cm ON p.post_id = cm.post_id
WHERE p.status = 'published'
GROUP BY p.post_id, u.username, c.name;
```

**Документна схема (MongoDB):**

```javascript
// Одна колекція з вбудованими даними
{
  _id: ObjectId("..."),
  title: "Назва статті",
  slug: "nazva-statti",
  content: "Текст статті...",
  excerpt: "Короткий опис...",
  author: {
    user_id: ObjectId("..."),
    username: "ivan_developer",
    avatar_url: "..."
  },
  category: {
    category_id: ObjectId("..."),
    name: "Веброзробка"
  },
  tags: ["mongodb", "nosql", "database"],
  comments: [
    {
      comment_id: ObjectId("..."),
      author: { user_id: ObjectId("..."), username: "maria" },
      text: "Коментар...",
      created_at: ISODate("2024-03-15")
    }
  ],
  statistics: {
    views: 542,
    likes: 34,
    comments_count: 5
  },
  status: "published",
  created_at: ISODate("2024-03-10"),
  published_at: ISODate("2024-03-10")
}

// Простий запит без JOIN
db.posts.find({ status: "published" });
```

**Порівняльна таблиця:**

| Критерій | PostgreSQL | MongoDB |
|----------|------------|---------|
| Кількість таблиць/колекцій | 7 таблиць | 3 колекції |
| Складність запитів | Високаскладні JOIN | Прості find() |
| Продуктивність читання | Залежить від JOIN | Швидше (без JOIN) |
| Продуктивність запису | Швидше (нормалізація) | Повільніше (денормалізація) |
| Гнучкість схеми | Жорстка, потребує міграцій | Гнучка |
| Цілісність даних | FOREIGN KEY constraints | Програмна валідація |
| Масштабованість | Вертикальна | Горизонтальна |
| Консистентність | ACID гарантії | Eventual consistency |

## Критерії оцінювання

### Рівень 1 (35-49 балів)

- Коректна схема документів для всіх колекцій з валідацією (12 балів).
- Заповнення бази даних реалістичними даними згідно вимог (12 балів).
- Розробка агрегаційних запитів для статистики (12 балів).
- Створення індексів для оптимізації (4 бали).
- Робочий HTML інтерфейс для відображення постів (9 балів).

### Рівень 2 (50-74 балів)

Усі завдання рівня 1 плюс:

- Система тегів з пошуком за множинними тегами (4 бали).
- Повнотекстовий пошук за назвою та змістом (4 бали).
- Система рейтингів з лайками (3 бали).
- Пагінація через агрегаційний pipeline (4 бали).
- Статистика переглядів з інкрементацією (3 бали).
- Модерація коментарів (3 бали).
- Вебформа для додавання постів (4 бали).

### Рівень 3 (75-100 балів)

Усі завдання рівня 2 плюс:

- Версіонування постів з історією редагувань (4 бали).
- Вкладені коментарі з рекурсивною структурою (4 бали).
- Система сповіщень для авторів (3 бали).
- Геолокація постів з пошуком (3 бали).
- Аналітична панель з візуалізацією (4 бали).
- RESTful API для взаємодії (4 бали).
- Система кешування (3 бали).
- Детальний порівняльний аналіз з тестами продуктивності (3 бали).

## Контрольні запитання

1. Які принципи слід враховувати при проєктуванні документної схеми для NoSQL баз даних?
2. Коли доцільно використовувати вбудовані документи, а коли посилання між документами?
3. Поясніть переваги та недоліки денормалізації даних в документних базах даних.
4. Як реалізувати ефективну пагінацію в MongoDB для великих обсягів даних?
5. Що таке патерн "Bucket" і для яких завдань він використовується?
6. Як забезпечити консистентність даних при денормалізації в MongoDB?
7. Які стратегії індексування найбільш ефективні для блог-системи?
8. Поясніть різницю між горизонтальним та вертикальним масштабуванням баз даних.
9. Як реалізувати транзакції в MongoDB і які обмеження вони мають?
10. Які метрики продуктивності важливі при порівнянні реляційних та документних баз даних?

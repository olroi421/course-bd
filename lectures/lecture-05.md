# Лекція 5. Концептуальне моделювання предметних областей

## Вступ

Проектування бази даних є складним процесом, що вимагає ретельного планування та послідовного підходу. Концептуальне моделювання становить фундаментальну основу цього процесу, оскільки саме на цьому етапі визначаються основні сутності предметної області, їхні властивості та взаємозв'язки. Правильно виконане концептуальне моделювання забезпечує створення ефективної, масштабованої та зрозумілої структури бази даних.

Концептуальна модель служить мостом між реальним світом предметної області та технічною реалізацією бази даних. Вона дозволяє проектувальникам та зацікавленим сторонам спілкуватися однією мовою, незалежно від конкретної технології реалізації.

## Методологія проектування БД: концептуальний, логічний, фізичний рівні

### Трирівнева архітектура проектування

Процес проектування бази даних традиційно розділяється на три основні рівні, кожен з яких має свої специфічні завдання та результати.

#### Концептуальний рівень

Концептуальний рівень є найвищим рівнем абстракції в процесі проектування. На цьому етапі проектувальник зосереджується на розумінні предметної області та визначенні її основних компонентів без урахування технічних деталей реалізації.

Основні завдання концептуального рівня:

- Ідентифікація основних сутностей предметної області та їхніх атрибутів.
- Визначення зв'язків між сутностями та їхніх характеристик.
- Встановлення бізнес-правил та обмежень цілісності.
- Створення концептуальної схеми, зрозумілої для всіх зацікавлених сторін.

Результатом концептуального моделювання є концептуальна схема, яка представляє повний та точний опис предметної області. Ця схема є незалежною від конкретної системи управління базами даних та технології реалізації.

Приклад концептуального опису для системи управління університетом:

```mermaid
erDiagram
    STUDENT {
        string student_id
        string first_name
        string last_name
        date birth_date
        string email
    }

    COURSE {
        string course_id
        string course_name
        int credits
        string description
    }

    ENROLLMENT {
        date enrollment_date
        string grade
        int semester
    }

    STUDENT ||--o{ ENROLLMENT : enrolls
    COURSE ||--o{ ENROLLMENT : includes
```

#### Логічний рівень

Логічний рівень є проміжним етапом, на якому концептуальна модель трансформується у структуру, що відповідає вибраній моделі даних. Для реляційних баз даних це означає перетворення концептуальної схеми у набір таблиць з визначеними зв'язками.

Основні завдання логічного рівня:

- Перетворення сутностей у таблиці з відповідними стовпцями.
- Реалізація зв'язків через зовнішні ключі або додаткові таблиці.
- Визначення типів даних для кожного атрибута.
- Встановлення первинних та зовнішніх ключів.
- Застосування правил нормалізації для усунення аномалій.

Приклад логічної схеми для системи управління університетом:

```sql
CREATE TABLE students (
    student_id VARCHAR(10) PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE,
    email VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE courses (
    course_id VARCHAR(10) PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL,
    credits INT CHECK (credits > 0),
    description TEXT
);

CREATE TABLE enrollments (
    student_id VARCHAR(10),
    course_id VARCHAR(10),
    enrollment_date DATE DEFAULT CURRENT_DATE,
    grade CHAR(2),
    semester INT,
    PRIMARY KEY (student_id, course_id, semester),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

#### Фізичний рівень

Фізичний рівень є найнижчим рівнем проектування, на якому визначаються специфічні деталі реалізації для конкретної системи управління базами даних. На цьому етапі приймаються рішення щодо оптимізації продуктивності та ефективного використання ресурсів.

Основні завдання фізичного рівня:

- Створення індексів для оптимізації запитів.
- Визначення стратегій секціонування великих таблиць.
- Налаштування параметрів зберігання та розміщення файлів.
- Оптимізація структур доступу до даних.
- Створення матеріалізованих представлень для складних запитів.

Приклад фізичних оптимізацій:

```sql
-- Створення індексів для оптимізації пошуку
CREATE INDEX idx_students_email ON students(email);
CREATE INDEX idx_enrollments_student ON enrollments(student_id);
CREATE INDEX idx_enrollments_course ON enrollments(course_id);

-- Створення композитного індексу для складних запитів
CREATE INDEX idx_enrollments_composite ON enrollments(semester, grade);

-- Налаштування параметрів таблиці
ALTER TABLE enrollments SET (fillfactor = 80);

-- Створення секціонування за семестрами
CREATE TABLE enrollments_2024_fall
PARTITION OF enrollments
FOR VALUES IN (202401);
```

### Взаємозв'язок між рівнями

Всі три рівні проектування тісно взаємопов'язані та впливають один на одного. Зміни на концептуальному рівні можуть потребувати перегляду логічної та фізичної структури. Водночас, обмеження фізичного рівня можуть впливати на рішення логічного рівня.

```mermaid
graph TD
    A[Концептуальний рівень] --> B[Логічний рівень]
    B --> C[Фізичний рівень]

    A1[Сутності, атрибути, зв'язки] --> A
    A2[Бізнес-правила] --> A
    A3[Обмеження цілісності] --> A

    B1[Таблиці, стовпці] --> B
    B2[Первинні та зовнішні ключі] --> B
    B3[Нормалізація] --> B

    C1[Індекси] --> C
    C2[Секціонування] --> C
    C3[Фізичне розміщення] --> C
```

## Entity-Relationship модель: сутності, атрибути, зв'язки

### Сутності

Сутність є основним будівельним блоком концептуальної моделі даних. Вона представляє певний клас об'єктів реального світу, які мають спільні характеристики та можуть бути однозначно ідентифіковані.

#### Типи сутностей

Розрізняють декілька типів сутностей залежно від їхніх характеристик та ролі в моделі:

**Сильні сутності** мають власний унікальний ідентифікатор, який не залежить від інших сутностей. Такі сутності можуть існувати незалежно та мають власний первинний ключ.

Приклади сильних сутностей:
- СТУДЕНТ (ідентифікується номером студентського квитка)
- КУРС (ідентифікується кодом курсу)
- ВИКЛАДАЧ (ідентифікується особистим номером)

**Слабкі сутності** не мають власного унікального ідентифікатора та залежать від іншої сутності для своєї ідентифікації. Вони існують тільки в контексті пов'язаної з ними сильної сутності.

Приклади слабких сутностей:
- ПІДЛЕГЛИЙ (ідентифікується в контексті конкретного співробітника)
- КІМНАТА (ідентифікується в контексті конкретної будівлі)

```mermaid
erDiagram
    EMPLOYEE {
        int employee_id
        string name
        string position
    }

    DEPENDENT {
        string name
        date birth_date
        string relationship
    }

    EMPLOYEE ||--o{ DEPENDENT : has
```

### Атрибути

Атрибути описують властивості сутностей та містять конкретні дані, що характеризують кожен екземпляр сутності.

#### Класифікація атрибутів

**Прості атрибути** містять одне атомарне значення, яке не може бути розділене на менші компоненти.

Приклади простих атрибутів:
- вік студента
- номер телефону
- дата народження

**Складені атрибути** можуть бути розділені на менші підкомпоненти, кожен з яких має самостійне значення.

Приклад складеного атрибута АДРЕСА:
- вулиця
- місто
- поштовий індекс
- країна

**Однозначні атрибути** можуть мати тільки одне значення для конкретного екземпляра сутності в певний момент часу.

**Багатозначні атрибути** можуть мати множину значень для одного екземпляра сутності.

Приклади багатозначних атрибутів:
- номери телефонів особи
- хобі студента
- мови, якими володіє викладач

**Похідні атрибути** обчислюються на основі інших атрибутів та не зберігаються безпосередньо в базі даних.

Приклади похідних атрибутів:
- вік (обчислюється з дати народження)
- загальна кількість кредитів студента
- стаж роботи співробітника

```mermaid
erDiagram
    PERSON {
        int person_id
        string first_name
        string last_name
        date birth_date
        int age "derived"
        string street
        string city
        string postal_code
        string phone_numbers "multivalued"
    }
```

#### Ключові атрибути

Ключові атрибути або комбінації атрибутів унікально ідентифікують кожен екземпляр сутності. Розрізняють первинні та альтернативні ключі.

Первинний ключ є основним ідентифікатором сутності та має такі властивості:
- унікальність для кожного екземпляра
- незмінність протягом життєвого циклу екземпляра
- простота та зрозумілість

### Зв'язки

Зв'язки представляють асоціації між двома або більше сутностями та описують, як екземпляри цих сутностей пов'язані між собою.

#### Типи зв'язків за кількістю учасників

**Бінарні зв'язки** включають дві сутності та є найпоширенішими в концептуальному моделюванні.

Приклад бінарного зв'язку:
- СТУДЕНТ навчається на КУРСІ
- ВИКЛАДАЧ викладає КУРС

**Тернарні зв'язки** включають три сутності одночасно та використовуються, коли зв'язок не може бути адекватно представлений набором бінарних зв'язків.

Приклад тернарного зв'язку:
- СТУДЕНТ здає КУРС у ВИКЛАДАЧА

**N-арні зв'язки** включають n сутностей, але на практиці використовуються рідко через складність інтерпретації.

#### Атрибути зв'язків

Зв'язки можуть мати власні атрибути, які характеризують асоціацію між сутностями.

Приклади атрибутів зв'язків:
- оцінка в зв'язку СТУДЕНТ-КУРС
- дата початку в зв'язку СПІВРОБІТНИК-ПРОЕКТ
- роль у зв'язку АКТОР-ФІЛЬМ

```mermaid
erDiagram
    STUDENT {
        int student_id
        string name
    }

    COURSE {
        int course_id
        string title
    }

    ENROLLMENT {
        date enrollment_date
        string grade
        int semester
    }

    STUDENT ||--o{ ENROLLMENT : ""
    COURSE ||--o{ ENROLLMENT : ""
```

## Семантичні обмеження: кардинальність, участь, ідентифікація

### Кардинальність зв'язків

Кардинальність визначає максимальну кількість екземплярів однієї сутності, які можуть бути пов'язані з одним екземпляром іншої сутності.

#### Типи кардинальності

**Один до одного (1:1)** означає, що кожен екземпляр першої сутності пов'язаний максимум з одним екземпляром другої сутності, і навпаки.

Приклади зв'язків 1:1:
- СПІВРОБІТНИК має РОБОЧЕ_МІСЦЕ
- КРАЇНА має СТОЛИЦЮ
- ОСОБА має ПАСПОРТ

**Один до багатьох (1:M)** означає, що кожен екземпляр першої сутності може бути пов'язаний з багатьма екземплярами другої сутності, але кожен екземпляр другої сутності пов'язаний максимум з одним екземпляром першої.

Приклади зв'язків 1:M:
- ВІДДІЛ містить багатьох СПІВРОБІТНИКІВ
- КУРС читається одним ВИКЛАДАЧЕМ
- ЗАМОВЛЕННЯ містить багато ТОВАРНИХ_ПОЗИЦІЙ

**Багато до багатьох (M:N)** означає, що кожен екземпляр будь-якої сутності може бути пов'язаний з багатьма екземплярами іншої сутності.

Приклади зв'язків M:N:
- СТУДЕНТ вивчає багато КУРСІВ
- АКТОР грає в багатьох ФІЛЬМАХ
- АВТОР пише багато КНИГ

```mermaid
erDiagram
    %% Зв'язок 1:1
    PERSON ||--|| PASSPORT : has

    %% Зв'язок 1:M
    DEPARTMENT ||--o{ EMPLOYEE : employs

    %% Зв'язок M:N
    STUDENT }o--o{ COURSE : enrolls
```

### Участь у зв'язках

Участь визначає, чи повинен кожен екземпляр сутності обов'язково брати участь у зв'язку.

#### Типи участі

**Повна участь (обов'язкова)** означає, що кожен екземпляр сутності повинен брати участь принаймні в одному екземплярі зв'язку. Графічно позначається подвійною лінією.

Приклади повної участі:
- кожен СПІВРОБІТНИК повинен працювати в якомусь ВІДДІЛІ
- кожна СЛАБКА_СУТНІСТЬ повинна бути пов'язана з ВЛАСНИЦЬКОЮ_СУТНІСТЮ

**Часткова участь (необов'язкова)** означає, що екземпляр сутності може, але не повинен брати участь у зв'язку. Графічно позначається одинарною лінією.

Приклади часткової участі:
- СПІВРОБІТНИК може керувати ПРОЕКТОМ
- СТУДЕНТ може бути СТАРОСТОЮ групи

```mermaid
erDiagram
    EMPLOYEE {
        int employee_id
        string name
    }

    DEPARTMENT {
        int dept_id
        string name
    }

    PROJECT {
        int project_id
        string title
    }

    %% Повна участь співробітника у відділі
    EMPLOYEE }|--|| DEPARTMENT : works_in

    %% Часткова участь співробітника в управлінні проектом
    EMPLOYEE ||--o{ PROJECT : manages
```

### Ідентифікуючі зв'язки

Ідентифікуючі зв'язки використовуються для визначення слабких сутностей, які не мають власного унікального ідентифікатора.

#### Характеристики ідентифікуючих зв'язків

- Слабка сутність має повну участь в ідентифікуючому зв'язку.
- Ідентифікуючий зв'язок завжди має кардинальність 1:M від власницької до слабкої сутності.
- Частковий ключ слабкої сутності в комбінації з ключем власницької сутності утворює повний ключ слабкої сутності.

Приклад ідентифікуючого зв'язку:

```mermaid
erDiagram
    BUILDING {
        int building_id
        string name
        string address
    }

    ROOM {
        string room_number
        int floor
        int capacity
    }

    %% Ідентифікуючий зв'язок
    BUILDING ||--o{ ROOM : contains
```

У цьому прикладі кімната ідентифікується комбінацією ідентифікатора будівлі та номера кімнати.

## Розширена ER-модель: узагальнення/спеціалізація, категорії, агрегація

### Узагальнення та спеціалізація

Узагальнення та спеціалізація є процесами створення ієрархічних відношень між сутностями, що дозволяють моделювати успадкування атрибутів та зв'язків.

#### Узагальнення

Узагальнення є процесом об'єднання кількох схожих сутностей в одну більш загальну сутність вищого рівня. Цей процес виділяє спільні атрибути та зв'язки підлеглих сутностей.

Приклад узагальнення:
- СТУДЕНТ, ВИКЛАДАЧ, АДМІНІСТРАТОР узагальнюються в ОСОБУ

#### Спеціалізація

Спеціалізація є зворотним процесом до узагальнення і полягає в розділенні загальної сутності на кілька більш специфічних підтипів.

Приклад спеціалізації:
- ТРАНСПОРТНИЙ_ЗАСІБ спеціалізується на АВТОМОБІЛЬ, МОТОЦИКЛ, ВАНТАЖІВКА

```mermaid
erDiagram
    PERSON {
        int person_id
        string first_name
        string last_name
        date birth_date
        string email
    }

    STUDENT {
        string student_number
        date enrollment_date
        string major
    }

    FACULTY {
        string employee_id
        string department
        string position
        decimal salary
    }

    STAFF {
        string employee_id
        string department
        string job_title
        decimal hourly_rate
    }

    PERSON ||--o{ STUDENT : isa
    PERSON ||--o{ FACULTY : isa
    PERSON ||--o{ STAFF : isa
```

#### Обмеження спеціалізації

**Обмеження диз'юнктності:**
- Диз'юнктна спеціалізація означає, що сутність може належати тільки одному підтипу.
- Перехресна спеціалізація дозволяє сутності належати кільком підтипам одночасно.

**Обмеження повноти:**
- Повна спеціалізація означає, що кожен екземпляр надтипу повинен належати принаймні одному підтипу.
- Часткова спеціалізація дозволяє екземплярам надтипу не належати жодному підтипу.

### Категорії (Union Types)

Категорії використовуються, коли підтип може бути пов'язаний з більш ніж одним надтипом. Це відрізняється від звичайної спеціалізації, де всі підтипи мають спільний надтип.

Приклад категорії:
- ВЛАСНИК може бути ОСОБОЮ або ОРГАНІЗАЦІЄЮ
- ТРАНСПОРТНИЙ_ЗАСІБ може належати ОСОБІ або КОМПАНІЇ

```mermaid
erDiagram
    PERSON {
        int person_id
        string name
    }

    ORGANIZATION {
        int org_id
        string company_name
    }

    VEHICLE {
        string license_plate
        string make
        string model
        int year
    }

    OWNER {
        int owner_id
    }

    PERSON ||--o{ OWNER : isa
    ORGANIZATION ||--o{ OWNER : isa
    OWNER ||--o{ VEHICLE : owns
```

### Агрегація

Агрегація дозволяє розглядати зв'язок разом з його учасниками як сутність вищого рівня. Це корисно, коли потрібно створити зв'язки з іншими сутностями на рівні всієї агрегації.

Приклад агрегації:
Зв'язок між СТУДЕНТОМ, КУРСОМ та ВИКЛАДАЧЕМ може бути агрегований в сутність НАВЧАННЯ, яка потім може мати зв'язки з іншими сутностями, такими як АУДИТОРІЯ.

```mermaid
erDiagram
    STUDENT {
        int student_id
        string name
    }

    COURSE {
        int course_id
        string title
    }

    INSTRUCTOR {
        int instructor_id
        string name
    }

    TEACHING_ASSIGNMENT {
        string semester
        int section_number
    }

    CLASSROOM {
        string room_number
        int capacity
    }

    STUDENT }o--o{ TEACHING_ASSIGNMENT : enrolls
    COURSE ||--o{ TEACHING_ASSIGNMENT : includes
    INSTRUCTOR ||--o{ TEACHING_ASSIGNMENT : teaches
    TEACHING_ASSIGNMENT }o--|| CLASSROOM : held_in
```

## Альтернативні нотації концептуального моделювання

### Нотація Чена (Chen)

Нотація Пітера Чена є класичною нотацією для ER-діаграм, запропонованою у 1976 році. Вона використовує специфічні геометричні фігури для різних елементів моделі.

![Chen Notation](https://www.conceptdraw.com/How-To-Guide/picture/chen-erd.png)

#### Елементи нотації Чена:
- Прямокутники для сутностей
- Ромби для зв'язків
- Овали для атрибутів
- Лінії для з'єднання елементів
- Подвійні лінії для повної участі
- Подвійні прямокутники для слабких сутностей

### Нотація "пташиних лапок" (Crow's Foot)

Ця нотація, також відома як Information Engineering Notation, є однією з найпопулярніших у сучасному проектуванні баз даних.

![Crow's Foot Notation](https://www.ermodelexample.com/wp-content/uploads/2020/02/crows-foot-notation-data-model-in-ie-crows-feet-intended-for-crows-foot-erd-examples.png)

#### Характеристики нотації Crow's Foot:
- Використання символів на кінцях ліній для позначення кардинальності
- "Пташина лапка" позначає "багато"
- Одна лінія позначає "один"
- Кола позначають необов'язковість
- Перпендикулярні лінії позначають обов'язковість

```mermaid
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--o{ ORDER_LINE : contains
    PRODUCT ||--o{ ORDER_LINE : ordered
```

### UML Class Diagram Notation

Нотація UML адаптована для моделювання баз даних і широко використовується в об'єктно-орієнтованому проектуванні.

![UML Class Diagram Notation](https://cdn.visual-paradigm.com/guide/uml/uml-class-diagram-tutorial/17-class-diagram-example-order-system.png)

#### Особливості UML нотації:
- Класи представляються прямокутниками з трьома секціями
- Верхня секція містить ім'я класу
- Середня секція містить атрибути
- Нижня секція містить методи (для баз даних зазвичай порожня)
- Асоціації показуються лініями з мультиплісності

### IDEF1X

IDEF1X (Integration Definition for Information Modeling) є стандартом для концептуального моделювання даних, розробленим для потреб оборонної промисловості США.

![UML Class Diagram Notation](https://upload.wikimedia.org/wikipedia/commons/c/ca/B_5_1_IDEF1X_Diagram.jpg)

#### Характеристики IDEF1X:
- Чітке розрізнення між ідентифікуючими та не-ідентифікуючими зв'язками
- Строга типізація сутностей
- Детальна специфікація атрибутів
- Підтримка доменів даних

### Порівняння нотацій

| Нотація | Переваги | Недоліки | Сфера застосування |
|---------|----------|----------|-------------------|
| Чена | Класична, детальна | Складна для великих діаграм | Навчання, документація |
| Crow's Foot | Інтуїтивна, компактна | Обмежені можливості | Комерційні СУБД |
| UML | Інтеграція з об'єктним дизайном | Надлишкова для простих БД | Об'єктно-орієнтовані системи |
| IDEF1X | Строга методологія | Складна для освоєння | Великі корпоративні системи |

## Процес концептуального моделювання

### Етапи розробки концептуальної моделі

#### Етап 1: Аналіз вимог

Перший етап включає збір та аналіз інформації про предметну область:

- Проведення інтерв'ю з користувачами та експертами предметної області.
- Аналіз існуючих документів, форм та звітів.
- Вивчення бізнес-процесів та правил.
- Ідентифікація функціональних та не-функціональних вимог.

#### Етап 2: Ідентифікація сутностей

На цьому етапі визначаються основні сутності предметної області:

- Виділення іменників з опису предметної області.
- Групування схожих об'єктів у сутності.
- Визначення меж та обсягу кожної сутності.
- Перевірка необхідності та достатності сутностей.

#### Етап 3: Визначення атрибутів

Для кожної ідентифікованої сутності визначаються її атрибути:

- Ідентифікація властивостей, що описують сутність.
- Класифікація атрибутів за типами.
- Визначення ключових атрибутів.
- Встановлення обмежень на значення атрибутів.

#### Етап 4: Моделювання зв'язків

На цьому етапі визначаються та моделюються зв'язки між сутностями:

- Ідентифікація асоціацій між сутностями.
- Визначення кардинальності кожного зв'язку.
- Встановлення обмежень участі.
- Додавання атрибутів до зв'язків, якщо необхідно.

#### Етап 5: Валідація моделі

Останній етап включає перевірку правильності та повноти моделі:

- Перевірка відповідності бізнес-правилам.
- Валідація з користувачами та експертами.
- Тестування моделі на прикладах реальних даних.
- Оптимізація структури моделі.

### Типові помилки при концептуальному моделюванні

#### Неправильна ідентифікація сутностей

Найчастіші помилки:
- Моделювання атрибутів як сутностей
- Створення надлишкових сутностей
- Ігнорування важливих сутностей предметної області

#### Помилки в атрибутах

Типові проблеми:
- Включення складених атрибутів без їх розкладання на прості компоненти
- Неправильна ідентифікація багатозначних атрибутів
- Ігнорування похідних атрибутів
- Відсутність належних ключових атрибутів

#### Помилки в зв'язках

Найпоширеніші проблеми:
- Неправильне визначення кардинальності зв'язків
- Ігнорування важливих зв'язків між сутностями
- Створення надлишкових зв'язків
- Неправильне моделювання тернарних зв'язків як набору бінарних

#### Помилки в обмеженнях

Частіші недоліки:
- Нехтування бізнес-правилами при визначенні обмежень
- Неправильна специфікація участі в зв'язках
- Ігнорування семантичних обмежень предметної області

### Інструменти концептуального моделювання

#### Графічні редактори

Сучасні інструменти для створення ER-діаграм:

**Професійні інструменти:**
- ERwin Data Modeler - професійний інструмент для корпоративного моделювання
- PowerDesigner - комплексне рішення для моделювання даних та процесів
- ER/Studio - інструмент для проектування та документування баз даних

**Безкоштовні альтернативи:**
- MySQL Workbench - вбудовані засоби моделювання для MySQL
- pgModeler - спеціалізований інструмент для PostgreSQL
- draw.io (Diagrams.net) - веб-інструмент з підтримкою ER-діаграм

**Онлайн платформи:**
- Lucidchart - хмарна платформа для створення діаграм
- Creately - інтерактивний інструмент моделювання
- Cacoo - колаборативна платформа для діаграм

#### CASE-системи

Computer-Aided Software Engineering системи надають комплексний підхід до моделювання:

- Автоматична генерація коду бази даних з концептуальної моделі
- Підтримка версіонування моделей
- Інтеграція з системами управління проектами
- Колаборативна робота над моделями

## Практичний приклад: Моделювання системи управління бібліотекою

### Аналіз вимог

Розглянемо практичний приклад створення концептуальної моделі для системи управління бібліотекою. Система повинна підтримувати такі функції:

- Реєстрація читачів та управління їхніми обліковими записами
- Каталогізація книг та інших матеріалів
- Відстеження видачі та повернення матеріалів
- Управління штрафами за прострочення
- Резервування популярних видань

### Ідентифікація основних сутностей

На основі аналізу вимог можна виділити такі основні сутності:

**ЧИТАЧ** - особи, які користуються послугами бібліотеки
**КНИГА** - основні матеріали бібліотеки
**АВТОР** - творці літературних творів
**ВИДАВНИЦТВО** - організації, що публікують книги
**КАТЕГОРІЯ** - тематичні розділи каталогу
**ВИДАЧА** - факт передачі книги читачеві
**ШТРАФ** - фінансові санкції за порушення правил

### Детальна модель

```mermaid
erDiagram
    READER {
        int reader_id PK
        string first_name
        string last_name
        string email
        string phone
        date registration_date
        string address
        string status
    }

    BOOK {
        string isbn PK
        string title
        int publication_year
        string language
        int pages
        decimal price
        int available_copies
        int total_copies
    }

    AUTHOR {
        int author_id PK
        string first_name
        string last_name
        date birth_date
        string nationality
        string biography
    }

    PUBLISHER {
        int publisher_id PK
        string name
        string address
        string contact_email
        string phone
    }

    CATEGORY {
        int category_id PK
        string name
        string description
        int parent_category_id FK
    }

    LOAN {
        int loan_id PK
        date loan_date
        date due_date
        date return_date
        string status
    }

    FINE {
        int fine_id PK
        decimal amount
        date issue_date
        date payment_date
        string reason
        string status
    }

    RESERVATION {
        int reservation_id PK
        date reservation_date
        date expiry_date
        string status
    }

    %% Зв'язки між сутностями
    READER ||--o{ LOAN : borrows
    BOOK ||--o{ LOAN : borrowed
    LOAN ||--o{ FINE : incurs

    READER ||--o{ RESERVATION : makes
    BOOK ||--o{ RESERVATION : reserved

    AUTHOR }o--o{ BOOK : writes
    PUBLISHER ||--o{ BOOK : publishes
    CATEGORY ||--o{ BOOK : categorizes
    CATEGORY ||--o{ CATEGORY : subcategory
```

### Атрибути та їх характеристики

#### Сутність ЧИТАЧ

**Прості атрибути:**
- reader_id (ключовий) - унікальний ідентифікатор читача
- first_name, last_name - особисті дані
- email - для комунікації та ідентифікації
- phone - контактна інформація
- registration_date - дата реєстрації в бібліотеці
- status - активний, заблокований, видалений

**Складений атрибут:**
- address може включати вулицю, місто, поштовий індекс

#### Сутність КНИГА

**Ключові атрибути:**
- isbn - міжнародний стандартний номер книги (первинний ключ)

**Описові атрибути:**
- title - назва твору
- publication_year - рік видання
- language - мова видання
- pages - кількість сторінок
- price - вартість примірника

**Атрибути інвентаризації:**
- available_copies - доступні для видачі примірники
- total_copies - загальна кількість примірників

#### Зв'язок ВИДАЧА

Зв'язок між ЧИТАЧЕМ та КНИГОЮ має такі атрибути:
- loan_date - дата видачі
- due_date - термін повернення
- return_date - фактична дата повернення (може бути null)
- status - видана, повернена, прострочена

### Бізнес-правила та обмеження

#### Обмеження цілісності

1. **Читач не може взяти більше 5 книг одночасно**
2. **Книга може бути видана тільки якщо available_copies > 0**
3. **Штраф нараховується автоматично через день після due_date**
4. **Резервування автоматично скасовується через 7 днів**

#### Похідні атрибути

- Кількість днів прострочення = CURRENT_DATE - due_date (якщо позитивне)
- Сума штрафу = дні_прострочення × 2 грн
- Статус читача = "заблокований" якщо є несплачені штрафи > 50 грн

### Розширення моделі

#### Спеціалізація сутності МАТЕРІАЛ

Бібліотека може мати різні типи матеріалів:

```mermaid
erDiagram
    MATERIAL {
        string material_id PK
        string title
        string type
    }

    BOOK {
        string isbn
        int pages
        string binding_type
    }

    JOURNAL {
        string issn
        int issue_number
        string frequency
    }

    DVD {
        int duration
        string format
        string region_code
    }

    MATERIAL ||--o{ BOOK : isa
    MATERIAL ||--o{ JOURNAL : isa
    MATERIAL ||--o{ DVD : isa
```

#### Категорії з ієрархією

Система категорій може мати ієрархічну структуру:

```sql
-- Приклад ієрархії категорій
-- Комп'ютерні науки (1)
--   ├── Програмування (11)
--   │   ├── Web-розробка (111)
--   │   └── Мобільна розробка (112)
--   └── Бази даних (12)
--       ├── Реляційні СУБД (121)
--       └── NoSQL системи (122)
```

## Переходи від концептуальної до логічної моделі

### Перетворення сутностей

Кожна сутність концептуальної моделі перетворюється на таблицю логічної моделі:

```sql
-- Сутність ЧИТАЧ → таблиця readers
CREATE TABLE readers (
    reader_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(20),
    registration_date DATE DEFAULT CURRENT_DATE,
    street VARCHAR(100),
    city VARCHAR(50),
    postal_code VARCHAR(10),
    status VARCHAR(20) DEFAULT 'active'
        CHECK (status IN ('active', 'blocked', 'deleted'))
);
```

### Перетворення зв'язків

#### Зв'язки 1:1

Реалізуються через додавання зовнішнього ключа в одну з таблиць:

```sql
-- Якщо кожен читач має унікальний читацький квиток
ALTER TABLE readers ADD COLUMN card_number VARCHAR(20) UNIQUE;
```

#### Зв'язки 1:M

Реалізуються додаванням зовнішнього ключа в таблицю "багато":

```sql
-- Книга належить одному видавництву
ALTER TABLE books ADD COLUMN publisher_id INT
    REFERENCES publishers(publisher_id);
```

#### Зв'язки M:N

Реалізуються через створення окремої таблиці зв'язку:

```sql
-- Зв'язок між авторами та книгами
CREATE TABLE book_authors (
    book_isbn VARCHAR(13) REFERENCES books(isbn),
    author_id INT REFERENCES authors(author_id),
    author_role VARCHAR(50) DEFAULT 'author',
    PRIMARY KEY (book_isbn, author_id)
);
```

### Реалізація спеціалізації

Спеціалізація може бути реалізована кількома способами:

#### Підхід "одна таблиця на ієрархію"

```sql
CREATE TABLE materials (
    material_id VARCHAR(20) PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    material_type VARCHAR(20) NOT NULL,
    -- Атрибути для книг
    isbn VARCHAR(13),
    pages INT,
    binding_type VARCHAR(30),
    -- Атрибути для журналів
    issn VARCHAR(9),
    issue_number INT,
    frequency VARCHAR(20),
    -- Атрибути для DVD
    duration INT,
    format VARCHAR(10),
    region_code VARCHAR(5)
);
```

#### Підхід "одна таблиця на підклас"

```sql
CREATE TABLE materials (
    material_id VARCHAR(20) PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    material_type VARCHAR(20) NOT NULL
);

CREATE TABLE books (
    material_id VARCHAR(20) PRIMARY KEY
        REFERENCES materials(material_id),
    isbn VARCHAR(13) UNIQUE,
    pages INT,
    binding_type VARCHAR(30)
);

CREATE TABLE journals (
    material_id VARCHAR(20) PRIMARY KEY
        REFERENCES materials(material_id),
    issn VARCHAR(9),
    issue_number INT,
    frequency VARCHAR(20)
);
```

## Висновки

Концептуальне моделювання є критично важливим етапом проектування баз даних, що визначає успіх всього проекту. Правильно виконана концептуальна модель забезпечує:

1. **Чітке розуміння предметної області** всіма учасниками проекту
2. **Основу для логічного та фізичного проектування** бази даних
3. **Документацію бізнес-правил** та обмежень системи
4. **Можливість валідації** вимог з користувачами та експертами

Основні принципи успішного концептуального моделювання:

- Ретельний аналіз вимог та розуміння предметної області
- Використання відповідної нотації для команди та організації
- Ітеративний підхід з постійною валідацією моделі
- Баланс між деталізацією та зрозумілістю моделі
- Урахування майбутніх потреб та можливих розширень системи

Entity-Relationship модель залишається основним інструментом концептуального моделювання завдяки своїй експресивності та зрозумілості. Розширені можливості моделі, такі як спеціалізація, категорії та агрегація, дозволяють точно відображати складні аспекти реального світу.

Вибір конкретної нотації та інструментів моделювання залежить від специфіки проекту, кваліфікації команди та корпоративних стандартів. Незалежно від вибраних засобів, головною метою залишається створення точної, повної та зрозумілої моделі предметної області, яка служитиме надійною основою для подальшого проектування та розробки системи управління базами даних.

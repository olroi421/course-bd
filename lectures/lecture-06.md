# Лекція 6. Теорія нормалізації реляційних схем

## Вступ

Нормалізація є одним з найважливіших процесів при проектуванні реляційних баз даних. Цей процес дозволяє структурувати дані таким чином, щоб мінімізувати надмірність, уникнути аномалій при оновленні та забезпечити цілісність даних. Теорія нормалізації, розроблена Едгаром Коддом та розвинена його послідовниками, ґрунтується на математично строгих принципах та дає практичні інструменти для створення якісних схем баз даних.

Основна ідея нормалізації полягає в декомпозиції (розкладанні) таблиць на менші таблиці, які зв'язані між собою через зовнішні ключі. Це дозволяє зберігати кожен факт тільки в одному місці, що значно спрощує підтримку консистентності даних.

## Аномалії в ненормалізованих відношеннях

Перш ніж розглядати теорію нормалізації, важливо зрозуміти, які проблеми виникають у погано спроектованих схемах баз даних. Ці проблеми називаються аномаліями і є основною мотивацією для процесу нормалізації.

### Типи аномалій

Існують три основні типи аномалій, які можуть виникати в ненормалізованих відношеннях:

1. **Аномалії вставки (Insert Anomalies)**
2. **Аномалії оновлення (Update Anomalies)**
3. **Аномалії видалення (Delete Anomalies)**

### Приклад ненормалізованого відношення

Розглянемо таблицю СТУДЕНТ_КУРС_ВИКЛАДАЧ, яка містить інформацію про студентів, курси та викладачів:

```
СТУДЕНТ_КУРС_ВИКЛАДАЧ
+------------+----------------+-------------+-------------+------------------+------------------+-------+
| student_id | student_name   | student_addr| course_id   | course_name      | instructor_name  | grade |
+------------+----------------+-------------+-------------+------------------+------------------+-------+
| 1001       | Іван Петров    | вул. Лесі 5 | CS101       | Програмування    | Іваненко А.П.    | 5     |
| 1001       | Іван Петров    | вул. Лесі 5 | CS102       | Бази даних       | Петренко Б.І.    | 4     |
| 1002       | Марія Коваленко| вул. Київська 12| CS101   | Програмування    | Іваненко А.П.    | 5     |
| 1003       | Петро Сидоров  | вул. Рівненська 8| CS102  | Бази даних       | Петренко Б.І.    | 3     |
+------------+----------------+-------------+-------------+------------------+------------------+-------+
```

### Аномалії вставки

**Визначення:** Аномалії вставки виникають, коли неможливо додати певну інформацію до бази даних без додавання зайвих або неповних даних.

#### Приклади аномалій вставки:

**1. Неможливість додати новий курс без студента:**
Якщо університет вводить новий курс "CS103 - Алгоритми", який викладає "Сидоренко В.М.", але на нього ще ніхто не записався, то неможливо додати цю інформацію в таблицю, оскільки первинний ключ включає student_id.

**2. Дублювання інформації про студента:**
При реєстрації студента на новий курс доводиться повторно вводити всю інформацію про студента (ім'я, адресу), що створює надмірність та ризик помилок.

**Приклад:** Студент Іван Петров (1001) реєструється на курс CS103. Потрібно ввести:
```
| 1001 | Іван Петров | вул. Лесі 5 | CS103 | Алгоритми | Сидоренко В.М. | NULL |
```

Інформація "Іван Петров, вул. Лесі 5" дублюється.

### Аномалії оновлення

**Визначення:** Аномалії оновлення виникають, коли зміна однієї характеристики сутності вимагає оновлення кількох записів, що може призвести до неконсистентності даних.

#### Приклади аномалій оновлення:

**1. Зміна назви курсу:**
Якщо курс CS101 змінює назву з "Програмування" на "Основи програмування", потрібно оновити ВСІ записи, які містять цей курс. При цьому є ризик:
- Пропустити деякі записи
- Створити неконсистентний стан, де один курс має різні назви

**2. Зміна адреси студента:**
Якщо студент Іван Петров змінює адресу з "вул. Лесі 5" на "вул. Шевченка 10", потрібно оновити ВСІ записи з цим студентом.

**Приклад неконсистентного стану після неповного оновлення:**
```
+------------+----------------+-------------+-------------+------------------+------------------+-------+
| 1001       | Іван Петров    | вул. Шевченка 10| CS101   | Програмування    | Іваненко А.П.    | 5     |
| 1001       | Іван Петров    | вул. Лесі 5     | CS102   | Бази даних       | Петренко Б.І.    | 4     |
+------------+----------------+-------------+-------------+------------------+------------------+-------+
```

Тепер у студента дві різні адреси!

### Аномалії видалення

**Визначення:** Аномалії видалення виникають, коли видалення запису призводить до втрати інформації, яка не була призначена для видалення.

#### Приклади аномалій видалення:

**1. Втрата інформації про курс:**
Якщо студент Петро Сидоров (єдиний студент на курсі CS102) відраховується з університету, то при видаленні його запису втрачається вся інформація про курс "Бази даних" та викладача "Петренко Б.І.".

**2. Втрата інформації про викладача:**
При видаленні останнього студента з курсу зникає інформація про те, що цей курс викладає конкретний викладач.

**Приклад втрати інформації:**
Видаляємо запис:
```
| 1003 | Петро Сидоров | вул. Рівненська 8| CS102 | Бази даних | Петренко Б.І. | 3 |
```

Якщо це був єдиний запис з курсом CS102, то втрачається інформація:
- Курс CS102 має назву "Бази даних"
- Курс CS102 викладає Петренко Б.І.

### Кількісна оцінка проблем надмірності

Розглянемо кількісний аспект проблем у наведеному прикладі:

**Надмірність даних:**
- Ім'я студента повторюється стільки разів, скільки курсів він відвідує
- Назва курсу повторюється стільки разів, скільки студентів на нього записано
- Ім'я викладача повторюється для кожного студента на курсі

**Розрахунок надмірності:**
При 1000 студентів, 50 курсах і середньому навантаженні 5 курсів на студента:
- Загальна кількість записів: 1000 × 5 = 5000
- Повторення імен студентів: 5000 разів замість 1000
- Повторення назв курсів: ~100 разів за курс замість 1
- Повторення імен викладачів: ~100 разів за викладача замість 1

### Взаємозв'язок аномалій і нормальних форм

Кожна нормальна форма усуває певні типи аномалій:

**1НФ:** Усуває аномалії, пов'язані з неатомарними значеннями
**2НФ:** Усуває аномалії вставки та оновлення, пов'язані з частковими залежностями
**3НФ:** Усуває аномалії вставки та оновлення, пов'язані з транзитивними залежностями
**НФБК:** Усуває всі аномалії, пов'язані з функціональними залежностями

### Вартість аномалій

Аномалії мають не тільки теоретичне, але й практичне значення:

**Вартість зберігання:**
- Надмірні дані займають додатковий дисковий простір
- Збільшуються вимоги до пам'яті для кешування
- Зростає час створення резервних копій

**Вартість обслуговування:**
- Більше часу на оновлення даних
- Ризик помилок при множинних оновленнях
- Складність забезпечення консистентності

**Вартість розробки:**
- Додаткова логіка для підтримки консистентності
- Складніші процедури валідації даних
- Більше тестових сценаріїв

Розуміння цих аномалій є ключовим для усвідомлення важливості процесу нормалізації, який ми розглянемо далі.

## Функціональні залежності

### Визначення функціональних залежностей

Функціональна залежність є фундаментальним поняттям теорії нормалізації. Вона описує семантичні зв'язки між атрибутами відношення та визначає, як значення одних атрибутів впливають на значення інших.

**Визначення:** Нехай R(U) — відношення з множиною атрибутів U. Кажуть, що множина атрибутів Y функціонально залежить від множини атрибутів X (позначається X → Y), якщо для будь-яких двох кортежів t₁ та t₂ відношення R виконується умова: якщо t₁[X] = t₂[X], то t₁[Y] = t₂[Y].

Простіше кажучи, функціональна залежність X → Y означає, що значення атрибутів X однозначно визначають значення атрибутів Y. Якщо два рядки мають однакові значення для атрибутів X, то вони обов'язково матимуть однакові значення для атрибутів Y.

### Приклади функціональних залежностей

Розглянемо відношення СТУДЕНТ з атрибутами:
- student_id (код студента)
- student_name (ім'я студента)
- group_number (номер групи)
- group_curator (куратор групи)
- subject_code (код предмета)
- subject_name (назва предмета)
- grade (оцінка)

У цьому відношенні можна виділити наступні функціональні залежності:

1. **student_id → student_name** — код студента однозначно визначає його ім'я
2. **student_id → group_number** — код студента визначає номер групи
3. **group_number → group_curator** — номер групи визначає куратора
4. **subject_code → subject_name** — код предмета визначає його назву
5. **{student_id, subject_code} → grade** — комбінація студента та предмета визначає оцінку

### Типи функціональних залежностей

**Тривіальні функціональні залежності** — це залежності виду X → Y, де Y ⊆ X. Наприклад, {student_id, student_name} → student_id завжди виконується, оскільки student_id є частиною лівої частини.

**Нетривіальні функціональні залежності** — це залежності, де Y ⊄ X. Саме такі залежності є корисними для проектування баз даних.

**Повністю нетривіальні функціональні залежності** — це залежності, де Y ∩ X = ∅, тобто права та ліва частини не мають спільних атрибутів.

### Правила виведення Армстронга

Вільям Армстронг у 1974 році сформулював набір правил, які дозволяють виводити нові функціональні залежності з уже відомих. Ці правила є повними та коректними, тобто дозволяють отримати всі можливі функціональні залежності і тільки правильні.

#### Основні правила (аксіоми)

**Правило рефлексивності (Reflexivity):**
Якщо Y ⊆ X, то X → Y.

Це правило говорить, що множина атрибутів завжди функціонально визначає свою підмножину.

**Правило нарощування (Augmentation):**
Якщо X → Y, то XZ → YZ для будь-якої множини атрибутів Z.

Це означає, що до обох частин функціональної залежності можна додати однакову множину атрибутів.

**Правило транзитивності (Transitivity):**
Якщо X → Y та Y → Z, то X → Z.

Транзитивність дозволяє "ланцюжити" функціональні залежності.

#### Додаткові правила (можуть бути виведені з основних)

**Правило об'єднання (Union):**
Якщо X → Y та X → Z, то X → YZ.

**Правило розкладання (Decomposition):**
Якщо X → YZ, то X → Y та X → Z.

**Правило псевдотранзитивності (Pseudotransitivity):**
Якщо X → Y та YZ → W, то XZ → W.

### Приклад застосування правил Армстронга

Нехай у нас є наступні функціональні залежності:
- F₁: student_id → group_number
- F₂: group_number → group_curator
- F₃: student_id → student_name

Застосуємо правила Армстронга:

1. З F₁ та F₂ за правилом транзитивності: student_id → group_curator
2. З F₁ та F₃ за правилом об'єднання: student_id → {group_number, student_name}
3. З результату пункту 1 та F₃ за правилом об'єднання: student_id → {group_curator, student_name}

## Замикання множин атрибутів та функціональних залежностей

### Замикання множини атрибутів

**Визначення:** Замиканням множини атрибутів X відносно множини функціональних залежностей F (позначається X⁺) називається множина всіх атрибутів, які функціонально залежать від X.

Замикання показує, які атрибути можна однозначно визначити, знаючи значення атрибутів з множини X.

### Алгоритм обчислення замикання

```
Алгоритм CLOSURE(X, F):
1. result := X
2. REPEAT
3.     for each функціональна залежність Y → Z в F do
4.         if Y ⊆ result then
5.             result := result ∪ Z
6.         end if
7.     end for
8. UNTIL result не змінюється
9. return result
```

### Приклад обчислення замикання

Розглянемо відношення R(A, B, C, D, E) з функціональними залежностями:
- F₁: A → BC
- F₂: CD → E
- F₃: B → D
- F₄: E → A

Обчислимо замикання {A}⁺:

**Крок 1:** result = {A}

**Крок 2:** Перевіряємо кожну залежність:
- F₁: A → BC. Оскільки A ⊆ {A}, додаємо BC. result = {A, B, C}
- F₂: CD → E. CD ⊄ {A, B, C}, пропускаємо
- F₃: B → D. B ⊆ {A, B, C}, додаємо D. result = {A, B, C, D}
- F₄: E → A. E ⊄ {A, B, C, D}, пропускаємо

**Крок 3:** Перевіряємо знову:
- F₁: вже застосована
- F₂: CD → E. Тепер CD ⊆ {A, B, C, D}, додаємо E. result = {A, B, C, D, E}
- F₃: вже застосована
- F₄: E → A. E ⊆ {A, B, C, D, E}, але A вже є в result

**Результат:** {A}⁺ = {A, B, C, D, E}

### Замикання множини функціональних залежностей

**Визначення:** Замиканням множини функціональних залежностей F (позначається F⁺) називається множина всіх функціональних залежностей, які можна вивести з F за допомогою правил Армстронга.

### Еквівалентність множин функціональних залежностей

Дві множини функціональних залежностей F і G називаються еквівалентними (F ≡ G), якщо F⁺ = G⁺. Це означає, що вони мають однаковий набір наслідків.

### Мінімальне покриття

**Визначення:** Множина функціональних залежностей G є мінімальним покриттям для F, якщо:
1. G ≡ F (еквівалентність)
2. Права частина кожної залежності в G складається з одного атрибута
3. Жодну залежність не можна видалити з G без порушення еквівалентності
4. Жодний атрибут не можна видалити з лівої частини будь-якої залежності в G без порушення еквівалентності

Мінімальне покриття дозволяє представити множину функціональних залежностей в найбільш компактному вигляді.

## Нормальні форми

### Перша нормальна форма (1НФ)

**Визначення:** Відношення знаходиться в першій нормальній формі, якщо всі його атрибути мають атомарні (неподільні) значення.

Це означає, що в кожній комірці таблиці може знаходитися тільки одне значення, а не список або множина значень.

#### Приклад порушення 1НФ

```
СТУДЕНТ_ПРЕДМЕТИ
+------------+----------------+------------------+
| student_id | student_name   | subjects         |
+------------+----------------+------------------+
| 1001       | Іван Петров    | Математика, БД   |
| 1002       | Марія Коваленко| БД, Алгоритми    |
| 1003       | Петро Сидоров  | Математика       |
+------------+----------------+------------------+
```

Стовпець "subjects" містить список предметів, що порушує 1НФ.

#### Приведення до 1НФ

```
СТУДЕНТ_ПРЕДМЕТ
+------------+----------------+------------+
| student_id | student_name   | subject    |
+------------+----------------+------------+
| 1001       | Іван Петров    | Математика |
| 1001       | Іван Петров    | БД         |
| 1002       | Марія Коваленко| БД         |
| 1002       | Марія Коваленко| Алгоритми  |
| 1003       | Петро Сидоров  | Математика |
+------------+----------------+------------+
```

### Друга нормальна форма (2НФ)

**Визначення:** Відношення знаходиться в другій нормальній формі, якщо:
1. Воно знаходиться в 1НФ
2. Кожен неключовий атрибут повністю функціонально залежить від кожного можливого ключа

Повна функціональна залежність означає, що атрибут залежить від всього ключа, а не від його частини.

#### Приклад порушення 2НФ

```
СТУДЕНТ_ПРЕДМЕТ_ОЦІНКА
+------------+----------------+-------------+-------------+-------+
| student_id | student_name   | subject_id  | subject_name| grade |
+------------+----------------+-------------+-------------+-------+
| 1001       | Іван Петров    | S001        | Математика  | 5     |
| 1001       | Іван Петров    | S002        | БД          | 4     |
| 1002       | Марія Коваленко| S002        | БД          | 5     |
+------------+----------------+-------------+-------------+-------+
```

Композитний ключ: {student_id, subject_id}

Функціональні залежності:
- student_id → student_name (часткова залежність)
- subject_id → subject_name (часткова залежність)
- {student_id, subject_id} → grade

#### Приведення до 2НФ

Розбиваємо на три таблиці:

```
СТУДЕНТИ
+------------+----------------+
| student_id | student_name   |
+------------+----------------+
| 1001       | Іван Петров    |
| 1002       | Марія Коваленко|
+------------+----------------+

ПРЕДМЕТИ
+------------+-------------+
| subject_id | subject_name|
+------------+-------------+
| S001       | Математика  |
| S002       | БД          |
+------------+-------------+

ОЦІНКИ
+------------+------------+-------+
| student_id | subject_id | grade |
+------------+------------+-------+
| 1001       | S001       | 5     |
| 1001       | S002       | 4     |
| 1002       | S002       | 5     |
+------------+------------+-------+
```

### Третя нормальна форма (3НФ)

**Визначення:** Відношення знаходиться в третій нормальній формі, якщо:
1. Воно знаходиться в 2НФ
2. Жоден неключовий атрибут не залежить транзитивно від ключа

Транзитивна залежність виникає, коли неключовий атрибут A залежить від ключа K через інший неключовий атрибут B: K → B → A.

#### Приклад порушення 3НФ

```
СТУДЕНТИ_ГРУПИ
+------------+----------------+--------------+------------------+
| student_id | student_name   | group_number | group_curator    |
+------------+----------------+--------------+------------------+
| 1001       | Іван Петров    | КН-21        | Петренко А.І.    |
| 1002       | Марія Коваленко| КН-21        | Петренко А.І.    |
| 1003       | Петро Сидоров  | КН-22        | Іваненко Б.П.    |
+------------+----------------+--------------+------------------+
```

Функціональні залежності:
- student_id → student_name (пряма залежність від ключа)
- student_id → group_number (пряма залежність від ключа)
- group_number → group_curator (транзитивна залежність)

#### Приведення до 3НФ

```
СТУДЕНТИ
+------------+----------------+--------------+
| student_id | student_name   | group_number |
+------------+----------------+--------------+
| 1001       | Іван Петров    | КН-21        |
| 1002       | Марія Коваленко| КН-21        |
| 1003       | Петро Сидоров  | КН-22        |
+------------+----------------+--------------+

ГРУПИ
+--------------+------------------+
| group_number | group_curator    |
+--------------+------------------+
| КН-21        | Петренко А.І.    |
| КН-22        | Іваненко Б.П.    |
+--------------+------------------+
```

### Нормальна форма Бойса-Кодда (НФБК)

**Визначення:** Відношення знаходиться в нормальній формі Бойса-Кодда, якщо для кожної нетривіальної функціональної залежності X → Y атрибут або множина атрибутів X є суперключем відношення.

НФБК є більш строгою формою нормалізації порівняно з 3НФ. Вона усуває певні аномалії, які можуть залишатися в 3НФ при наявності перекриваючихся ключів-кандидатів.

#### Приклад порушення НФБК

```
КУРСИ_ВИКЛАДАЧІ
+-------------+------------------+-------------+
| course_code | instructor_name  | room_number |
+-------------+------------------+-------------+
| CS101       | Петров А.І.      | 301         |
| CS101       | Іваненко Б.П.    | 302         |
| CS102       | Петров А.І.      | 301         |
+-------------+------------------+-------------+
```

Припустимо, що:
- Один курс може викладатися кількома викладачами
- Кожен викладач має закріплену за ним аудиторію
- Ключі-кандидати: {course_code, instructor_name}

Функціональна залежність: instructor_name → room_number

Ця залежність порушує НФБК, оскільки instructor_name не є суперключем.

#### Приведення до НФБК

```
КУРСИ_ВИКЛАДАЧІ
+-------------+------------------+
| course_code | instructor_name  |
+-------------+------------------+
| CS101       | Петров А.І.      |
| CS101       | Іваненко Б.П.    |
| CS102       | Петров А.І.      |
+-------------+------------------+

ВИКЛАДАЧІ_АУДИТОРІЇ
+------------------+-------------+
| instructor_name  | room_number |
+------------------+-------------+
| Петров А.І.      | 301         |
| Іваненко Б.П.    | 302         |
+------------------+-------------+
```

## Багатозначні залежності та четверта нормальна форма

### Багатозначні залежності

**Визначення:** У відношенні R(X, Y, Z) існує багатозначна залежність X ↠ Y (читається "X багатозначно визначає Y"), якщо множина Y-значень, що відповідають заданому X-значенню, залежить тільки від X і не залежить від Z.

Багатозначна залежність виникає, коли один атрибут визначає множину значень іншого атрибута, незалежно від решти атрибутів у відношенні.

#### Приклад багатозначної залежності

```
СТУДЕНТ_ХОБІ_МОВИ
+------------+----------------+-----------+
| student_id | hobby          | language  |
+------------+----------------+-----------+
| 1001       | Футбол         | Англійська|
| 1001       | Футбол         | Німецька  |
| 1001       | Читання        | Англійська|
| 1001       | Читання        | Німецька  |
| 1002       | Плавання       | Французька|
+------------+----------------+-----------+
```

Тут student_id ↠ hobby та student_id ↠ language, оскільки хобі та мови студента не залежать одне від одного.

### Четверта нормальна форма (4НФ)

**Визначення:** Відношення знаходиться в четвертій нормальній формі, якщо:
1. Воно знаходиться в НФБК
2. Воно не містить нетривіальних багатозначних залежностей

#### Приведення до 4НФ

Розбиваємо відношення на два:

```
СТУДЕНТ_ХОБІ
+------------+----------+
| student_id | hobby    |
+------------+----------+
| 1001       | Футбол   |
| 1001       | Читання  |
| 1002       | Плавання |
+------------+----------+

СТУДЕНТ_МОВИ
+------------+-----------+
| student_id | language  |
+------------+-----------+
| 1001       | Англійська|
| 1001       | Німецька  |
| 1002       | Французька|
+------------+-----------+
```

## П'ята нормальна форма та залежності з'єднання

### Залежності з'єднання

**Визначення:** Відношення R має залежність з'єднання ⋈(R₁, R₂, ..., Rₙ), якщо R = R₁ ⋈ R₂ ⋈ ... ⋈ Rₙ, де R₁, R₂, ..., Rₙ є проекціями відношення R.

Залежність з'єднання описує ситуацію, коли відношення може бути точно відтворене з'єднанням своїх проекцій.

### П'ята нормальна форма (5НФ)

**Визначення:** Відношення знаходиться в п'ятій нормальній формі (також називається проекційно-з'єднувальною нормальною формою), якщо:
1. Воно знаходиться в 4НФ
2. Воно не може бути розкладене на менші відношення без втрат

#### Приклад залежності з'єднання

```
ПОСТАЧАЛЬНИК_ДЕТАЛЬ_ПРОЄКТ
+---------------+----------+---------+
| supplier_name | part_name| project |
+---------------+----------+---------+
| Smith         | Nut      | ProjX   |
| Smith         | Bolt     | ProjY   |
| Jones         | Nut      | ProjY   |
+---------------+----------+---------+
```

Якщо існують обмеження:
- Постачальник Smith постачає деталі Nut та Bolt
- Деталь Nut використовується в проєктах ProjX та ProjY
- Деталь Bolt використовується в проєкті ProjY

То таблицю можна розкласти на три проекції без втрат.

## Алгоритми декомпозиції

### Принципи декомпозиції

При розкладанні відношень на менші необхідно забезпечити дві важливі властивості:

1. **Безвтратність з'єднання** — можливість точно відтворити початкове відношення з'єднанням результатів декомпозиції
2. **Збереження залежностей** — всі функціональні залежності повинні бути збережені в результаті декомпозиції

### Алгоритм декомпозиції до 3НФ з збереженням залежностей

```
Алгоритм 3NF_SYNTHESIS(R, F):
1. Знайти мінімальне покриття Fc для F
2. Згрупувати залежності в Fc за лівими частинами
3. Для кожної групи створити відношення
4. Якщо жоден ключ R не зберігся, додати відношення з одним з ключів
5. Видалити надлишкові відношення
```

### Алгоритм декомпозиції до НФБК з безвтратним з'єднанням

```
Алгоритм BCNF_DECOMP(R, F):
1. result := {R}
2. WHILE існує відношення S в result, що не в НФБК DO
3.     Знайти функціональну залежність X → Y в S, що порушує НФБК
4.     Замінити S на S1(X ∪ Y) та S2(S - Y + X)
5.     Оновити множину функціональних залежностей
6. END WHILE
7. RETURN result
```

### Приклад декомпозиції

Розглянемо відношення STUDENT_COURSE_INSTRUCTOR з атрибутами:
- S (student_id)
- C (course_id)
- I (instructor_id)
- G (grade)

Функціональні залежності:
- F₁: {S, C} → G
- F₂: {S, C} → I
- F₃: I → C

F₃ порушує НФБК, оскільки I не є суперключем.

**Декомпозиція:**

1. **Крок 1:** Розкладаємо за F₃: I → C
   - R₁(I, C) з залежністю I → C
   - R₂(S, I, G) з залежностями {S, I} → G

2. **Перевірка:** R₁ та R₂ знаходяться в НФБК

**Результат:**
```
INSTRUCTOR_COURSE (I, C)
STUDENT_GRADE (S, I, G)
```

### Перевірка збереження залежностей

Для перевірки, чи зберігаються всі функціональні залежності після декомпозиції, використовується наступний алгоритм:

```
Алгоритм CHECK_PRESERVATION(R, F, D):
Для кожної залежності X → Y в F:
1. Обчислити (X)⁺ на об'єднанні всіх відношень з D
2. Якщо Y ⊆ (X)⁺, то залежність зберігається
3. Інакше залежність втрачена
```

### Перевірка безвтратності з'єднання

Для перевірки безвтратності декомпозиції використовується алгоритм таблиці чейз (chase):

```
Алгоритм LOSSLESS_CHECK(R, F, D):
1. Створити таблицю з |D| рядками та |R| стовпцями
2. Заповнити комірки символами aᵢⱼ або bᵢⱼ
3. Застосувати правила чейз для кожної залежності
4. Якщо з'явився рядок з усіма a-символами, декомпозиція безвтратна
```

## Практичні рекомендації

### Коли зупинятися в процесі нормалізації

Теоретично бажано досягти найвищої нормальної форми, але на практиці іноді доцільно зупинитися на 3НФ або НФБК з наступних причин:

1. **Продуктивність запитів** — більш нормалізовані схеми можуть вимагати більше з'єднань
2. **Складність запитів** — занадто багато таблиць ускладнюють написання та розуміння запитів
3. **Вимоги до консистентності** — деякі бізнес-правила можуть бути втрачені при надмірній нормалізації

### Денормалізація

У деяких випадках навмисно порушують принципи нормалізації для:

1. **Покращення продуктивності** читання
2. **Спрощення звітності**
3. **Зменшення кількості з'єднань**

Денормалізація завжди має бути обґрунтованою та супроводжуватися додатковими механізмами підтримки консистентності.

## Висновки

Теорія нормалізації є фундаментальним інструментом проектування якісних реляційних баз даних. Основні принципи, які слід пам'ятати:

1. **Функціональні залежності** описують семантичні зв'язки між атрибутами та є основою для нормалізації
2. **Правила Армстронга** дозволяють систематично виводити нові залежності з відомих
3. **Нормальні форми** створюють ієрархію вимог до структури відношень, де кожна наступна форма усуває певний тип аномалій
4. **Алгоритми декомпозиції** забезпечують систематичний підхід до розкладання відношень з збереженням важливих властивостей

Правильне застосування принципів нормалізації дозволяє створювати бази даних, які легко підтримувати, мають мінімальну надмірність та високу цілісність даних. Водночас важливо знайти баланс між теоретичною досконалістю та практичними потребами конкретної системи.
